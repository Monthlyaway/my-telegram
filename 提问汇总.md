Sessionå¯¹è±¡çš„ç”Ÿå‘½å‘¨æœŸåˆ†æ

  Sessionå¯¹è±¡çš„åˆ›å»º

  // åœ¨Server::do_accept()ä¸­åˆ›å»º
  auto new_session = std::make_shared<Session>(
      asio::ip::tcp::socket(io_context_),
      message_router_
  );

  æ­¤æ—¶new_sessionæ˜¯ä¸€ä¸ªshared_ptr<Session>ï¼Œå¼•ç”¨è®¡æ•°ä¸º1ã€‚

  Sessionå¯¹è±¡çš„å¼•ç”¨ç®¡ç†

  1. shared_from_this()çš„ä½œç”¨

  class Session : public std::enable_shared_from_this<Session> {
      void do_read() {
          auto self(shared_from_this());  // å¼•ç”¨è®¡æ•°+1
          socket_.async_read_some(
              asio::buffer(data_, max_length),
              [this, self](std::error_code ec, std::size_t length) {
                  // lambdaæ•è·äº†selfï¼Œå¼•ç”¨è®¡æ•°ä¿æŒ
                  if (!ec) {
                      // å¤„ç†æ•°æ®...
                      do_read();  // é€’å½’è°ƒç”¨ï¼Œåˆ›å»ºæ–°çš„self
                  }
                  // lambdaç»“æŸæ—¶ï¼Œselfææ„ï¼Œå¼•ç”¨è®¡æ•°-1
              }
          );
      }
  };

  å…³é”®ç‚¹: shared_from_this()ç¡®ä¿åœ¨å¼‚æ­¥æ“ä½œæœŸé—´Sessionå¯¹è±¡ä¸ä¼šè¢«æ„å¤–ææ„ã€‚

  2. SessionManagerä¸­çš„å¼•ç”¨

  class SessionManager {
      std::unordered_set<std::shared_ptr<Session>> active_sessions_;

      bool register_session(std::shared_ptr<Session> session) {
          active_sessions_.insert(session);  // å¼•ç”¨è®¡æ•°+1
      }

      bool unregister_session(std::shared_ptr<Session> session) {
          active_sessions_.erase(session);   // å¼•ç”¨è®¡æ•°-1
      }
  };

  Sessionææ„çš„è§¦å‘æ¡ä»¶

  æ¡ä»¶1: å®¢æˆ·ç«¯ä¸»åŠ¨æ–­å¼€è¿æ¥

  // å®¢æˆ·ç«¯æ‰§è¡Œï¼šCtrl+C æˆ– exit æˆ–å…³é—­telnet
  void Session::do_read() {
      auto self(shared_from_this());
      socket_.async_read_some(asio::buffer(data_, max_length),
          [this, self](std::error_code ec, std::size_t length) {
              if (ec) {
                  if (ec == asio::error::eof) {
                      spdlog::info("Client disconnected: End of file");
                  }
                  // ä¸å†è°ƒç”¨do_read()ï¼Œå¼‚æ­¥é“¾ä¸­æ–­
                  // lambdaç»“æŸæ—¶selfææ„ï¼Œå¦‚æœè¿™æ˜¯æœ€åä¸€ä¸ªå¼•ç”¨...
                  return;
              }
              // æ­£å¸¸æƒ…å†µç»§ç»­è¯»å–
              do_read();
          }
      );
  }

  åˆ†æè¿‡ç¨‹:
  1. å®¢æˆ·ç«¯æ–­å¼€ â†’ socketæ”¶åˆ°EOFé”™è¯¯
  2. async_read_someå›è°ƒæ”¶åˆ°ec = asio::error::eof
  3. ä¸å†è°ƒç”¨do_read()ï¼Œå¼‚æ­¥æ“ä½œé“¾ä¸­æ–­
  4. lambdaç»“æŸï¼Œselfå¯¹è±¡ææ„ï¼Œå¼•ç”¨è®¡æ•°-1
  5. å¦‚æœSessionManagerä¸­æ²¡æœ‰å…¶ä»–å¼•ç”¨ï¼ŒSessionå¯¹è±¡ææ„

  æ¡ä»¶2: ç½‘ç»œé”™è¯¯æˆ–è¶…æ—¶

  [this, self](std::error_code ec, std::size_t length) {
      if (ec) {
          if (ec == asio::error::connection_reset) {
              spdlog::info("Client disconnected: Connection reset by peer");
          } else if (ec == asio::error::timed_out) {
              spdlog::info("Client disconnected: Timeout");
          } else {
              spdlog::info("Client disconnected: {}", ec.message());
          }
          return;  // ä¸­æ–­å¼‚æ­¥é“¾
      }
  }

  å¸¸è§ç½‘ç»œé”™è¯¯:
  - connection_reset: å®¢æˆ·ç«¯å¼ºåˆ¶å…³é—­è¿æ¥
  - connection_aborted: è¿æ¥è¢«ç»ˆæ­¢
  - timed_out: ç½‘ç»œè¶…æ—¶
  - broken_pipe: ç®¡é“ç ´è£‚

  æ¡ä»¶3: æœåŠ¡å™¨ä¸»åŠ¨å…³é—­è¿æ¥

  void SessionManager::shutdown_all_sessions() {
      std::lock_guard<std::mutex> lock(sessions_mutex_);

      for (auto& session : active_sessions_) {
          if (session->socket_.is_open()) {
              session->socket_.close();  // ä¸»åŠ¨å…³é—­socket
          }
      }
      active_sessions_.clear();  // æ¸…é™¤æ‰€æœ‰å¼•ç”¨
      // æ‰€æœ‰Sessionå¯¹è±¡åœ¨è¿™é‡Œææ„
  }

  æ¡ä»¶4: å¼‚å¸¸å¯¼è‡´çš„ææ„

  void Session::handle_packet(const Packet& packet) {
      try {
          message_router_->route_message(packet, shared_from_this());
      } catch (const std::exception& e) {
          spdlog::error("Exception in packet handling: {}", e.what());
          // å¦‚æœå¼‚å¸¸å¯¼è‡´æ— æ³•ç»§ç»­å¤„ç†ï¼Œå¯èƒ½éœ€è¦å…³é—­è¿æ¥
          socket_.close();
          return;  // ä¸­æ–­å¤„ç†æµç¨‹
      }
  }

  å¼•ç”¨è®¡æ•°çš„è¯¦ç»†è·Ÿè¸ª

  æ­£å¸¸è¿è¡Œæ—¶çš„å¼•ç”¨æƒ…å†µ

  // å‡è®¾ä¸€ä¸ªSessionæ­£åœ¨è¿è¡Œ
  std::shared_ptr<Session> session;  // å¼•ç”¨è®¡æ•°åˆ†æ

  // 1. Serveråˆ›å»ºSession
  auto new_session = std::make_shared<Session>(...);  // å¼•ç”¨è®¡æ•° = 1

  // 2. æ³¨å†Œåˆ°SessionManager
  SessionManager::get_instance().register_session(new_session);  // å¼•ç”¨è®¡æ•° = 2

  // 3. å¼€å§‹å¼‚æ­¥è¯»å–
  new_session->start();
      â†“
  void Session::do_read() {
      auto self(shared_from_this());  // å¼•ç”¨è®¡æ•° = 3
      socket_.async_read_some(...,
          [this, self](...) {  // lambdaæ•è·selfï¼Œå¼•ç”¨è®¡æ•°ä¿æŒ = 3
              // å¤„ç†å®Œæˆåï¼Œlambdaææ„ï¼Œå¼•ç”¨è®¡æ•° = 2
          }
      );
  }

  // 4. Serverä¸­çš„new_sessionè¶…å‡ºä½œç”¨åŸŸ
  // new_sessionææ„ï¼Œå¼•ç”¨è®¡æ•° = 1ï¼ˆåªå‰©SessionManagerä¸­çš„å¼•ç”¨ï¼‰

  æ–­å¼€è¿æ¥æ—¶çš„å¼•ç”¨æ¸…ç†

  // å®¢æˆ·ç«¯æ–­å¼€æ—¶çš„å¼•ç”¨è®¡æ•°å˜åŒ–
  [this, self](std::error_code ec, std::size_t length) {
      if (ec == asio::error::eof) {
          spdlog::info("Client disconnected");
          // ä¸è°ƒç”¨do_read()ï¼Œå¼‚æ­¥é“¾ä¸­æ–­
          return;
      }
  }
  // lambdaç»“æŸï¼Œselfææ„ â†’ å¼•ç”¨è®¡æ•°ä»2å˜ä¸º1

  // Sessionææ„å‡½æ•°è¢«è°ƒç”¨
  Session::~Session() {
      // ä»SessionManageræ³¨é”€
      SessionManager::get_instance().unregister_session(shared_from_this());
      // â†‘ è¿™é‡Œä¼šè®©å¼•ç”¨è®¡æ•°ä»1å˜ä¸º0
      // Sessionå¯¹è±¡çœŸæ­£ææ„
  }

  ç‰¹æ®Šæƒ…å†µå’Œé™·é˜±

  é™·é˜±1: å¾ªç¯å¼•ç”¨

  // å±é™©çš„è®¾è®¡ï¼ˆç†è®ºä¸Šçš„é”™è¯¯ç¤ºä¾‹ï¼‰
  class Session {
      std::shared_ptr<Session> self_ref_;  // å±é™©ï¼

      void start() {
          self_ref_ = shared_from_this();  // åˆ›å»ºå¾ªç¯å¼•ç”¨
          // Sessionæ°¸è¿œä¸ä¼šææ„ï¼Œå› ä¸ºself_ref_æŒæœ‰å¼•ç”¨
      }
  };

  é™·é˜±2: è¿‡æ—©é‡Šæ”¾

  // é”™è¯¯çš„è®¾è®¡
  void Server::do_accept() {
      Session session(std::move(socket), router);  // æ ˆå¯¹è±¡ï¼Œä¸æ˜¯shared_ptr
      session.start();  // å¼€å§‹å¼‚æ­¥æ“ä½œ
      // å‡½æ•°ç»“æŸæ—¶sessionææ„ï¼Œä½†å¼‚æ­¥æ“ä½œè¿˜åœ¨è¿›è¡Œï¼
      // ä¼šå¯¼è‡´use-after-freeé”™è¯¯
  }

  æ­£ç¡®çš„æ¨¡å¼: RAII + shared_ptr

  void Server::do_accept() {
      auto new_session = std::make_shared<Session>(...);  // å †å¯¹è±¡
      new_session->start();  // å¼‚æ­¥æ“ä½œæŒæœ‰å¼•ç”¨
      // å‡½æ•°ç»“æŸæ—¶new_sessionææ„ï¼Œä½†Sessionå¯¹è±¡ç”±å¼‚æ­¥æ“ä½œä¿æŒå­˜æ´»
  }

  è°ƒè¯•Sessionç”Ÿå‘½å‘¨æœŸ

  å¯ä»¥åœ¨Sessionä¸­æ·»åŠ è°ƒè¯•æ—¥å¿—æ¥è§‚å¯Ÿç”Ÿå‘½å‘¨æœŸï¼š

  class Session {
      static std::atomic<int> session_counter_;
      int session_id_;

  public:
      Session(...) : session_id_(++session_counter_) {
          spdlog::debug("Session {} created, use_count: {}",
                       session_id_, shared_from_this().use_count());
      }

      ~Session() {
          spdlog::debug("Session {} destroyed", session_id_);
      }

      void do_read() {
          auto self(shared_from_this());
          spdlog::debug("Session {} async_read started, use_count: {}",
                       session_id_, self.use_count());
          // ...
      }
  };

  æ€»ç»“

  Sessionå¯¹è±¡ææ„çš„æ ¹æœ¬åŸå› æ˜¯å¼•ç”¨è®¡æ•°å½’é›¶ï¼Œè¿™é€šå¸¸å‘ç”Ÿåœ¨ï¼š

  1. å®¢æˆ·ç«¯æ–­å¼€è¿æ¥ â†’ å¼‚æ­¥æ“ä½œé“¾ä¸­æ–­ â†’ å¼•ç”¨è®¡æ•°å‡å°‘
  2. ç½‘ç»œé”™è¯¯ â†’ è¿æ¥ä¸å¯ç”¨ â†’ åœæ­¢å¼‚æ­¥æ“ä½œ
  3. æœåŠ¡å™¨å…³é—­ â†’ ä¸»åŠ¨æ¸…ç†æ‰€æœ‰ä¼šè¯
  4. å¼‚å¸¸å¤„ç† â†’ æ— æ³•ç»§ç»­å¤„ç†ï¼Œä¸»åŠ¨å…³é—­

  å…³é”®è®¾è®¡æ¨¡å¼ï¼š
  - shared_ptr + enable_shared_from_this: ç¡®ä¿å¼‚æ­¥æ“ä½œæœŸé—´å¯¹è±¡å­˜æ´»
  - RAII: å¯¹è±¡ææ„æ—¶è‡ªåŠ¨æ¸…ç†èµ„æº
  - å¼•ç”¨ç®¡ç†: SessionManageræŒæœ‰å¼•ç”¨ï¼Œç¡®ä¿å¯ä»¥ç»Ÿä¸€ç®¡ç†

  è¿™ç§è®¾è®¡æ—¢ä¿è¯äº†å†…å­˜å®‰å…¨ï¼Œåˆæä¾›äº†çµæ´»çš„ç”Ÿå‘½å‘¨æœŸç®¡ç†ã€‚

---

éå¸¸å¥½çš„é—®é¢˜ï¼è¿™æ¶‰åŠåˆ°æ¶æ„è®¾è®¡çš„æ ¸å¿ƒå†³ç­–ã€‚è®©æˆ‘åˆ†æä¸ºä»€ä¹ˆSessionManageré€‰æ‹©äº†å•ä¾‹æ¨¡å¼ï¼Œä»¥åŠå…¶ä»–å¯èƒ½çš„è®¾è®¡æ–¹æ¡ˆã€‚

  å½“å‰å•ä¾‹è®¾è®¡çš„åŸå› 

  1. å…¨å±€çŠ¶æ€ç®¡ç†éœ€æ±‚

  // å•ä¾‹æ¨¡å¼ç¡®ä¿å…¨å±€åªæœ‰ä¸€ä¸ªä¼šè¯æ³¨å†Œä¸­å¿ƒ
  SessionManager& manager = SessionManager::get_instance();
  manager.register_session(session);  // æ‰€æœ‰Sessionæ³¨å†Œåˆ°åŒä¸€ä¸ªç®¡ç†å™¨

  æ ¸å¿ƒéœ€æ±‚: æœåŠ¡å™¨éœ€è¦ä¸€ä¸ª"å…¨å±€çš„ä¼šè¯æ³¨å†Œä¸­å¿ƒ"ï¼Œæ‰€æœ‰Sessionéƒ½æ³¨å†Œåˆ°åŒä¸€ä¸ªåœ°æ–¹ï¼Œè¿™æ ·æ‰èƒ½ï¼š
  - ç»Ÿè®¡æ€»çš„æ´»è·ƒè¿æ¥æ•°
  - å®ç°å…¨æœåŠ¡å™¨å¹¿æ’­
  - ç»Ÿä¸€ç®¡ç†æ‰€æœ‰ä¼šè¯

  2. é¿å…å¤šå®ä¾‹æ··ä¹±

  å¦‚æœä¸æ˜¯å•ä¾‹ï¼Œå¯èƒ½å‡ºç°ï¼š
  // å±é™©çš„å¤šå®ä¾‹åœºæ™¯
  SessionManager manager1;  // Session1æ³¨å†Œåˆ°è¿™é‡Œ
  SessionManager manager2;  // Session2æ³¨å†Œåˆ°è¿™é‡Œ

  // é—®é¢˜ï¼š
  manager1.get_active_session_count();  // è¿”å›1
  manager2.get_active_session_count();  // è¿”å›1
  // å®é™…æ€»è¿æ¥æ•°æ˜¯2ï¼Œä½†æ²¡æœ‰åœ°æ–¹èƒ½å¾—åˆ°æ­£ç¡®ç­”æ¡ˆï¼

  3. è·¨æ¨¡å—è®¿é—®ä¾¿åˆ©æ€§

  // Sessionææ„æ—¶éœ€è¦æ³¨é”€
  Session::~Session() {
      // æ–¹ä¾¿ï¼šæ— éœ€ä¼ é€’SessionManagerå¼•ç”¨
      SessionManager::get_instance().unregister_session(shared_from_this());
  }

  // æœªæ¥æ¶ˆæ¯è·¯ç”±å™¨å¯èƒ½éœ€è¦å¹¿æ’­
  void MessageRouter::broadcast_system_message(const std::string& msg) {
      // æ–¹ä¾¿ï¼šç›´æ¥è®¿é—®å…¨å±€ä¼šè¯ç®¡ç†å™¨
      SessionManager::get_instance().broadcast_to_all(msg);
  }

  ä½†æ˜¯ï¼å•ä¾‹æ¨¡å¼çš„é—®é¢˜

  1. å…¨å±€çŠ¶æ€çš„å±é™©æ€§

  // å•ä¾‹çš„é—®é¢˜ï¼šå…¨å±€çŠ¶æ€éš¾ä»¥æµ‹è¯•
  class TestCase {
      void test_session_management() {
          // é—®é¢˜ï¼šå¦‚ä½•é‡ç½®SessionManagerçš„çŠ¶æ€ï¼Ÿ
          // ä¹‹å‰æµ‹è¯•çš„Sessionå¯èƒ½è¿˜åœ¨é‡Œé¢
          SessionManager::get_instance().clear();  // éœ€è¦ä¸“é—¨çš„æµ‹è¯•æ¥å£
      }
  };

  2. ä¾èµ–æ³¨å…¥å›°éš¾

  // å•ä¾‹æ¨¡å¼ä¸‹ï¼Œå¾ˆéš¾mockæˆ–æ›¿æ¢SessionManager
  class MockSessionManager : public SessionManager {
      // æ— æ³•è½»æ˜“æ›¿æ¢å•ä¾‹å®ä¾‹ç”¨äºæµ‹è¯•
  };

  3. çº¿ç¨‹å®‰å…¨å¤æ‚æ€§

  // å•ä¾‹éœ€è¦çº¿ç¨‹å®‰å…¨çš„åˆå§‹åŒ–
  SessionManager& SessionManager::get_instance() {
      static SessionManager instance;  // C++11ä¿è¯çº¿ç¨‹å®‰å…¨ï¼Œä½†å¢åŠ å¤æ‚æ€§
      return instance;
  }

  æ›¿ä»£è®¾è®¡æ–¹æ¡ˆ

  æ–¹æ¡ˆ1: ä¾èµ–æ³¨å…¥åˆ°Server

  class Server {
  private:
      std::shared_ptr<SessionManager> session_manager_;

  public:
      Server(const Config& config)
          : session_manager_(std::make_shared<SessionManager>()) {
      }

      void do_accept() {
          auto new_session = std::make_shared<Session>(
              asio::ip::tcp::socket(io_context_),
              message_router_,
              session_manager_  // æ³¨å…¥SessionManager
          );
      }
  };

  ä¼˜ç‚¹:
  - æ›´å¥½çš„æµ‹è¯•æ€§ï¼šå¯ä»¥æ³¨å…¥MockSessionManager
  - ä¾èµ–å…³ç³»æ›´æ˜ç¡®
  - æ›´å®¹æ˜“ç†è§£å¯¹è±¡ç”Ÿå‘½å‘¨æœŸ

  ç¼ºç‚¹:
  - éœ€è¦ä¼ é€’SessionManagerå¼•ç”¨åˆ°å¾ˆå¤šåœ°æ–¹
  - Sessionææ„æ—¶è®¿é—®SessionManagerå˜å¤æ‚

  æ–¹æ¡ˆ2: äº‹ä»¶å‘å¸ƒè®¢é˜…æ¨¡å¼

  class SessionEventBus {
  public:
      void publish_session_created(std::shared_ptr<Session> session);
      void publish_session_destroyed(std::shared_ptr<Session> session);

      void subscribe_session_events(SessionEventListener* listener);
  };

  class SessionManager : public SessionEventListener {
      void on_session_created(std::shared_ptr<Session> session) override {
          // å“åº”ä¼šè¯åˆ›å»ºäº‹ä»¶
      }
  };

  ä¼˜ç‚¹:
  - è§£è€¦ï¼šSessionä¸ç›´æ¥ä¾èµ–SessionManager
  - å¯æ‰©å±•ï¼šå¤šä¸ªç›‘å¬å™¨å¯ä»¥å“åº”ä¼šè¯äº‹ä»¶
  - äº‹ä»¶é©±åŠ¨æ¶æ„

  ç¼ºç‚¹:
  - å¢åŠ å¤æ‚æ€§
  - å¼‚æ­¥äº‹ä»¶å¯èƒ½å¯¼è‡´æ—¶åºé—®é¢˜

  æ–¹æ¡ˆ3: RAIIä¼šè¯ä»¤ç‰Œ

  class SessionToken {
  private:
      SessionManager* manager_;
      Session* session_;

  public:
      SessionToken(SessionManager* mgr, Session* sess)
          : manager_(mgr), session_(sess) {
          manager_->register_session(session_);
      }

      ~SessionToken() {
          manager_->unregister_session(session_);
      }
  };

  class Session {
  private:
      std::unique_ptr<SessionToken> token_;

  public:
      Session(socket, router, session_manager)
          : token_(std::make_unique<SessionToken>(session_manager, this)) {
      }
  };

  ä¼˜ç‚¹:
  - RAIIè‡ªåŠ¨ç®¡ç†æ³¨å†Œ/æ³¨é”€
  - æ˜ç¡®çš„ç”Ÿå‘½å‘¨æœŸç®¡ç†
  - é¿å…é—å¿˜æ³¨é”€çš„bug

  ç¼ºç‚¹:
  - å¢åŠ äº†ä¸€ä¸ªä¸­é—´å±‚
  - ç¨å¾®å¤æ‚çš„å¯¹è±¡æ¨¡å‹

  ä¸ºä»€ä¹ˆå½“å‰é€‰æ‹©äº†å•ä¾‹ï¼Ÿ

  åœ¨MyTelegramé¡¹ç›®ä¸­é€‰æ‹©å•ä¾‹æ¨¡å¼çš„ä¸»è¦åŸå› ï¼š

  1. ç®€å•æ€§ä¼˜å…ˆ

  // å½“å‰é˜¶æ®µçš„éœ€æ±‚ç›¸å¯¹ç®€å•
  // å•ä¾‹æ¨¡å¼æœ€ç›´æ¥åœ°æ»¡è¶³"å…¨å±€ä¼šè¯ç®¡ç†"éœ€æ±‚
  SessionManager::get_instance().register_session(session);

  2. å¿«é€Ÿå¼€å‘

  - ä¸éœ€è¦è®¾è®¡å¤æ‚çš„ä¾èµ–æ³¨å…¥æ¡†æ¶
  - ä¸éœ€è¦å¤„ç†SessionManagerçš„ç”Ÿå‘½å‘¨æœŸç®¡ç†
  - Sessionå¯ä»¥ç›´æ¥è®¿é—®ï¼Œæ— éœ€é¢å¤–å‚æ•°ä¼ é€’

  3. æœªæ¥å¯é‡æ„

  // å¦‚æœå°†æ¥éœ€è¦ï¼Œå¯ä»¥é‡æ„ä¸ºä¾èµ–æ³¨å…¥
  class SessionManager {
  public:
      static SessionManager& get_instance() {
          // å¯ä»¥æ”¹ä¸ºè¿”å›æ³¨å…¥çš„å®ä¾‹
          return *injected_instance_;
      }

      static void set_instance(std::shared_ptr<SessionManager> instance) {
          injected_instance_ = instance;
      }
  };

  æœ€ä½³å®è·µå»ºè®®

  å¯¹äºä¸åŒé˜¶æ®µçš„é¡¹ç›®ï¼š

  | é¡¹ç›®é˜¶æ®µ    | æ¨èæ–¹æ¡ˆ      | åŸå›           |
  |---------|-----------|-------------|
  | åŸå‹/å­¦ä¹ é¡¹ç›® | å•ä¾‹æ¨¡å¼      | ç®€å•ç›´æ¥ï¼Œå¿«é€Ÿå¼€å‘   |
  | ä¸­å‹é¡¹ç›®    | ä¾èµ–æ³¨å…¥      | æ›´å¥½çš„æµ‹è¯•æ€§å’Œå¯ç»´æŠ¤æ€§ |
  | å¤§å‹ä¼ä¸šé¡¹ç›®  | äº‹ä»¶æ€»çº¿+DIå®¹å™¨ | æœ€å¤§çš„çµæ´»æ€§å’Œå¯æ‰©å±•æ€§ |

  æ€»ç»“

  SessionManageré€‰æ‹©å•ä¾‹æ¨¡å¼æ˜¯ä¸€ä¸ªå®ç”¨ä¸»ä¹‰çš„é€‰æ‹©ï¼š

  âœ… ä¼˜ç‚¹: ç®€å•ã€ç›´æ¥ã€å¿«é€Ÿæ»¡è¶³éœ€æ±‚
  âŒ ç¼ºç‚¹: å…¨å±€çŠ¶æ€ã€æµ‹è¯•å›°éš¾ã€çµæ´»æ€§è¾ƒä½

  åœ¨å½“å‰çš„å­¦ä¹ å’ŒåŸå‹å¼€å‘é˜¶æ®µï¼Œå•ä¾‹æ¨¡å¼æ˜¯åˆç†çš„é€‰æ‹©ã€‚ä½†å¦‚æœè¿™ä¸ªé¡¹ç›®è¦æŠ•å…¥ç”Ÿäº§ç¯å¢ƒæˆ–éœ€è¦ä¸¥æ ¼çš„å•å…ƒæµ‹è¯•ï¼Œä¾èµ–æ³¨å…¥ä¼šæ˜¯æ›´å¥½
  çš„æ–¹æ¡ˆã€‚

  è¿™å°±æ˜¯æ¶æ„è®¾è®¡ä¸­çš„ç»å…¸æƒè¡¡ï¼šç®€å•æ€§ vs çµæ´»æ€§ï¼Œå¼€å‘é€Ÿåº¦ vs é•¿æœŸç»´æŠ¤æ€§ã€‚

---

è¿™æ˜¯ä¸€ä¸ªéå¸¸å¥½çš„é—®é¢˜ï¼è®©æˆ‘è¯¦ç»†è§£é‡Šä¸ºä»€ä¹ˆæˆ‘ä»¬éœ€è¦SessionManagerï¼Œä»¥åŠå®ƒè§£å†³äº†å“ªäº›åœ¨ç®€å•åœºæ™¯ä¸‹ä¸æ˜æ˜¾ä½†åœ¨ä¼ä¸šçº§åº”ç”¨ä¸­è‡³
  å…³é‡è¦çš„é—®é¢˜ã€‚

  ä½ è¯´å¾—å¯¹ï¼šç®€å•åœºæ™¯ä¸‹ç¡®å®å¯ä»¥å·¥ä½œ

  åœ¨é˜¶æ®µ2å’Œé˜¶æ®µ3ä¸­ï¼Œæ²¡æœ‰SessionManagerçš„ä»£ç ç¡®å®å¯ä»¥æ­£å¸¸å·¥ä½œï¼š
  - Serverå¯ä»¥æ¥å—telnetè¿æ¥
  - æ¯ä¸ªSessionç‹¬ç«‹å¤„ç†è‡ªå·±çš„è¿æ¥
  - å¤šçº¿ç¨‹å¯ä»¥å¹¶è¡Œå¤„ç†echoè¯·æ±‚
  - è¿æ¥æ–­å¼€æ—¶Sessionè‡ªåŠ¨ææ„

  ä½†æ˜¯ï¼Œéšè—çš„é—®é¢˜åœ¨å“ªé‡Œï¼Ÿ

  1. ä¼šè¯è¿½è¸ªå’Œç›‘æ§

  é—®é¢˜: æ²¡æœ‰SessionManageræ—¶ï¼ŒServeræ— æ³•çŸ¥é“ï¼š
  - å½“å‰æœ‰å¤šå°‘æ´»è·ƒè¿æ¥ï¼Ÿ
  - å†å²æœ€å¤§å¹¶å‘è¿æ¥æ•°æ˜¯å¤šå°‘ï¼Ÿ
  - å“ªäº›å®¢æˆ·ç«¯è¿æ¥äº†å¤šé•¿æ—¶é—´ï¼Ÿ

  ç°å®åœºæ™¯:
  // æ²¡æœ‰SessionManager - æ— æ³•ç»Ÿè®¡
  telnet localhost 8080  // è¿æ¥1
  telnet localhost 8080  // è¿æ¥2
  telnet localhost 8080  // è¿æ¥3
  // é—®é¢˜ï¼šæœåŠ¡å™¨ç®¡ç†å‘˜æ— æ³•çŸ¥é“å½“å‰æœ‰3ä¸ªè¿æ¥

  æœ‰SessionManagerå:
  [info] Session registered, active sessions: 1
  [info] Session registered, active sessions: 2
  [info] Session registered, active sessions: 3
  [info] SessionManager Stats: Active=3, MaxEver=5

  2. èµ„æºæ³„éœ²å’Œä¼˜é›…å…³é—­

  é—®é¢˜: æ²¡æœ‰SessionManageræ—¶ï¼ŒServerå…³é—­æ—¶ï¼š
  - æ— æ³•ä¸»åŠ¨å…³é—­æ‰€æœ‰æ´»è·ƒè¿æ¥
  - å®¢æˆ·ç«¯å¯èƒ½é•¿æ—¶é—´ç­‰å¾…
  - èµ„æºæ¸…ç†ä¸å½»åº•

  ä»£ç å¯¹æ¯”:
  // æ²¡æœ‰SessionManagerçš„Server::stop()
  void Server::stop() {
      acceptor_.close();
      io_context_.stop();
      // é—®é¢˜ï¼šæ— æ³•é€šçŸ¥ç°æœ‰çš„Sessionè¿æ¥
      // å®¢æˆ·ç«¯ä¼šæ”¶åˆ°çªç„¶çš„è¿æ¥æ–­å¼€
  }

  // æœ‰SessionManagerçš„Server::stop()
  void Server::stop() {
      // ä¼˜é›…å…³é—­æ‰€æœ‰ä¼šè¯
      SessionManager::get_instance().shutdown_all_sessions();
      acceptor_.close();
      io_context_.stop();
      // æ‰€æœ‰å®¢æˆ·ç«¯æ”¶åˆ°æ­£å¸¸çš„è¿æ¥å…³é—­
  }

  3. è¿æ¥æ•°é™åˆ¶å’Œæµæ§

  é—®é¢˜: æ²¡æœ‰SessionManageræ—¶æ— æ³•ï¼š
  - é™åˆ¶æœ€å¤§å¹¶å‘è¿æ¥æ•°
  - å®ç°è¿æ¥æµæ§
  - æ‹’ç»è¿‡å¤šè¿æ¥ä»¥ä¿æŠ¤æœåŠ¡å™¨

  æœªæ¥æ‰©å±•åœºæ™¯:
  // SessionManagerå¯ä»¥å¾ˆå®¹æ˜“æ·»åŠ è¿æ¥é™åˆ¶
  bool SessionManager::register_session(std::shared_ptr<Session> session) {
      std::lock_guard<std::mutex> lock(sessions_mutex_);

      if (active_sessions_.size() >= MAX_CONNECTIONS) {
          spdlog::warn("Connection limit reached, rejecting new session");
          return false;  // æ‹’ç»æ–°è¿æ¥
      }

      active_sessions_.insert(session);
      return true;
  }

  4. å¹¿æ’­å’Œå¤šæ’­æ”¯æŒ

  é—®é¢˜: æ²¡æœ‰SessionManageræ—¶æ— æ³•ï¼š
  - å‘æ‰€æœ‰è¿æ¥çš„å®¢æˆ·ç«¯å¹¿æ’­æ¶ˆæ¯
  - å®ç°ç¾¤èŠåŠŸèƒ½
  - æŸ¥æ‰¾ç‰¹å®šç”¨æˆ·çš„Session

  æœªæ¥ç¾¤èŠåœºæ™¯:
  // éœ€è¦SessionManageræ‰èƒ½å®ç°çš„åŠŸèƒ½
  void SessionManager::broadcast_message(const Packet& packet) {
      std::lock_guard<std::mutex> lock(sessions_mutex_);

      for (auto& session : active_sessions_) {
          session->send_packet(packet);  // å¹¿æ’­ç»™æ‰€æœ‰åœ¨çº¿ç”¨æˆ·
      }
  }

  void SessionManager::send_to_user(const std::string& username, const Packet& packet) {
      // æ ¹æ®ç”¨æˆ·åæŸ¥æ‰¾å¯¹åº”çš„Sessionå¹¶å‘é€æ¶ˆæ¯
  }

  5. è°ƒè¯•å’Œè¿ç»´ç›‘æ§

  é—®é¢˜: æ²¡æœ‰SessionManageræ—¶ï¼š
  - æ— æ³•ç”Ÿæˆè¿æ¥æŠ¥å‘Š
  - éš¾ä»¥è°ƒè¯•è¿æ¥ç›¸å…³é—®é¢˜
  - æ— æ³•å®æ—¶ç›‘æ§æœåŠ¡å™¨çŠ¶æ€

  è¿ç»´ä»·å€¼:
  // SessionManageræä¾›çš„ç›‘æ§èƒ½åŠ›
  std::string SessionManager::get_detailed_stats() const {
      return fmt::format(
          "Active: {}, Peak: {}, Total Handled: {}, Avg Duration: {}s",
          active_sessions_.size(),
          max_session_count_.load(),
          total_sessions_handled_,
          average_session_duration_
      );
  }

  å®é™…çš„ä¼ä¸šçº§éœ€æ±‚å¯¹æ¯”

  | åŠŸèƒ½éœ€æ±‚   | æ— SessionManager | æœ‰SessionManager |
  |--------|-----------------|-----------------|
  | åŸºç¡€Echo | âœ… å¯ä»¥å·¥ä½œ          | âœ… å¯ä»¥å·¥ä½œ          |
  | è¿æ¥ç»Ÿè®¡   | âŒ æ— æ³•ç»Ÿè®¡          | âœ… å®æ—¶ç»Ÿè®¡          |
  | ä¼˜é›…å…³é—­   | âŒ çªç„¶æ–­å¼€          | âœ… æ­£å¸¸å…³é—­          |
  | è¿æ¥é™åˆ¶   | âŒ æ— æ³•é™åˆ¶          | âœ… å¯é…ç½®é™åˆ¶         |
  | å¹¿æ’­æ¶ˆæ¯   | âŒ æ— æ³•å®ç°          | âœ… è½»æ¾å®ç°          |
  | è¿ç»´ç›‘æ§   | âŒ æ— ç›‘æ§æ•°æ®         | âœ… è¯¦ç»†ç›‘æ§          |
  | ç”¨æˆ·æŸ¥æ‰¾   | âŒ æ— æ³•æŸ¥æ‰¾          | âœ… å¿«é€ŸæŸ¥æ‰¾          |

  æ¶æ„æ¼”è¿›çš„å¿…ç„¶æ€§

  graph TD
      A[é˜¶æ®µ2: ç®€å•Echo] --> B[é˜¶æ®µ3: Protobuf]
      B --> C[é˜¶æ®µ4: è·¯ç”±+ä¼šè¯ç®¡ç†]
      C --> D[é˜¶æ®µ5: ç”¨æˆ·ç³»ç»Ÿ]
      D --> E[é˜¶æ®µ6: ç§èŠ]
      E --> F[é˜¶æ®µ7: ç¾¤èŠ]

      style C fill:#e1f5fe
      style D fill:#fff3e0
      style E fill:#fff3e0
      style F fill:#fff3e0

  - é˜¶æ®µ4: SessionManagerä¸ºå¤šç”¨æˆ·åŠŸèƒ½æ‰“åŸºç¡€
  - é˜¶æ®µ5: éœ€è¦æ ¹æ®ç”¨æˆ·IDæŸ¥æ‰¾Session
  - é˜¶æ®µ6: éœ€è¦å‘ç‰¹å®šç”¨æˆ·å‘é€ç§èŠæ¶ˆæ¯
  - é˜¶æ®µ7: éœ€è¦å‘ç¾¤ç»„æˆå‘˜å¹¿æ’­æ¶ˆæ¯

  æ€»ç»“

  ä½ çš„è§‚å¯Ÿå¾ˆæ•é”ï¼åœ¨ç®€å•çš„echoåœºæ™¯ä¸‹ï¼ŒSessionManagerç¡®å®ä¸æ˜¯å¿…éœ€çš„ã€‚ä½†æ˜¯ï¼š

  1. ç°åœ¨å¼•å…¥SessionManageræ˜¯ä¸ºäº†æ¶æ„çš„å‰ç»æ€§ - ä¸ºåç»­çš„ç”¨æˆ·ç³»ç»Ÿã€ç§èŠã€ç¾¤èŠåŠŸèƒ½å¥ å®šåŸºç¡€
  2. ä¼ä¸šçº§åº”ç”¨éœ€è¦ç›‘æ§å’Œç®¡ç†èƒ½åŠ› - è¿ç»´äººå‘˜éœ€è¦çŸ¥é“æœåŠ¡å™¨çŠ¶æ€
  3. ä¼˜é›…å…³é—­å’Œèµ„æºç®¡ç† - ä¿è¯æœåŠ¡é‡å¯æ—¶çš„ç”¨æˆ·ä½“éªŒ
  4. å¯æ‰©å±•æ€§è®¾è®¡ - æ”¯æŒæœªæ¥æ·»åŠ è¿æ¥é™åˆ¶ã€å¹¿æ’­ç­‰åŠŸèƒ½

  è¿™å°±æ˜¯ä¸ºä»€ä¹ˆæˆ‘ä»¬è¦åœ¨"èƒ½å·¥ä½œ"çš„åŸºç¡€ä¸Šè¿›ä¸€æ­¥å®Œå–„æ¶æ„ - ä¸ºäº†æ”¯æ’‘æ›´å¤æ‚çš„ä¸šåŠ¡éœ€æ±‚å’Œæ›´å¥½çš„è¿ç»´ä½“éªŒã€‚

---

å¥½é—®é¢˜ ğŸ‘ `shared_from_this` æ˜¯å¾ˆå¤š **Asio æœåŠ¡ç«¯/å®¢æˆ·ç«¯ä»£ç **é‡Œçš„æ ¸å¿ƒç‚¹ã€‚åº•å±‚å®ƒåšäº†ä¸¤ä»¶å…³é”®çš„äº‹æƒ…ï¼š

---

### 1. `std::enable_shared_from_this<T>` çš„åŸç†

å½“ä½ å†™ï¼š

```cpp
class Session : public std::enable_shared_from_this<Session>
```

ç¼–è¯‘å™¨ä¼šæŠŠ `Session` ç±»ç»§æ‰¿è‡ªä¸€ä¸ªæ¨¡ç‰ˆåŸºç±»ï¼š

```cpp
template <class T>
class enable_shared_from_this {
protected:
    enable_shared_from_this() noexcept {}
    enable_shared_from_this(const enable_shared_from_this&) noexcept {}
    enable_shared_from_this& operator=(const enable_shared_from_this&) noexcept { return *this; }
    ~enable_shared_from_this() {}

public:
    std::shared_ptr<T> shared_from_this() {
        return std::shared_ptr<T>(weak_this_);
    }

    std::shared_ptr<const T> shared_from_this() const {
        return std::shared_ptr<const T>(weak_this_);
    }

private:
    mutable std::weak_ptr<T> weak_this_;

    friend class std::shared_ptr<T>;  // å…³é”®ï¼šåªæœ‰ shared_ptr<T> æ‰èƒ½è®¿é—® weak_this_
};
```

æ ¸å¿ƒåœ¨ **`weak_this_`** ï¼š

* æ¯ä¸€ä¸ªç»§æ‰¿äº† `enable_shared_from_this` çš„å¯¹è±¡ï¼Œé‡Œé¢éƒ½æœ‰ä¸€ä¸ª `weak_ptr<T>` æˆå‘˜ã€‚
* å½“ä½ ç¬¬ä¸€æ¬¡ç”¨ `std::make_shared<Session>()` åˆ›å»ºå¯¹è±¡æ—¶ï¼Œ`shared_ptr` æ„é€ å‡½æ•°ä¼š **å·å·æŠŠ this å­˜è¿› weak\_this\_**ã€‚

æ‰€ä»¥ä»¥åå†è°ƒç”¨ `shared_from_this()` æ—¶ï¼Œå®ƒå°±ï¼š

* ä» `weak_this_` åˆ›å»ºä¸€ä¸ªæ–°çš„ `shared_ptr`ï¼ˆå¼•ç”¨è®¡æ•° +1ï¼‰ã€‚
* è¿”å›è¿™ä¸ªæ™ºèƒ½æŒ‡é’ˆï¼Œä¿è¯ç”Ÿå‘½å‘¨æœŸå®‰å…¨ã€‚

---

### 2. `shared_from_this` åœ¨å›è°ƒé‡Œçš„ä½œç”¨

æ¥çœ‹ä½ å†™çš„ä¾‹å­ï¼š

```cpp
void do_read() {
    auto self(shared_from_this());  // âœ… å¼•ç”¨è®¡æ•° +1
    socket_.async_read_some(
        asio::buffer(data_, max_length),
        [this, self](std::error_code ec, std::size_t length) {
            // lambda æ•è· self
            if (!ec) {
                do_read();  // é€’å½’è¯»
            }
            // lambda ç»“æŸï¼Œself ææ„ â†’ å¼•ç”¨è®¡æ•° -1
        }
    );
}
```

è¿™é‡Œä¸ºä»€ä¹ˆå¿…é¡»ç”¨ `shared_from_this()`ï¼Ÿ

* `async_read_some` æ˜¯å¼‚æ­¥çš„ï¼šè°ƒç”¨åå‡½æ•°ç«‹å³è¿”å›ï¼ŒIO æ“ä½œè¿˜åœ¨åå°è¿›è¡Œã€‚
* å¦‚æœä½ åªæ˜¯ `[this]` æ•è·è£¸æŒ‡é’ˆï¼š

  * å¯èƒ½åœ¨å¼‚æ­¥å›è°ƒè§¦å‘å‰ï¼Œ`Session` å·²ç»è¢«é”€æ¯ï¼›
  * å›è°ƒå‡½æ•°é‡Œè®¿é—® `this` å°±ä¼š **æ‚¬ç©ºæŒ‡é’ˆ â†’ å´©æºƒ**ã€‚
* `shared_from_this()` ä¿è¯äº†ï¼š

  * åœ¨å›è°ƒ lambda æ•è· `self` æ—¶ï¼Œå¼•ç”¨è®¡æ•° +1ï¼›
  * å³ä½¿ç”¨æˆ·åœ¨åˆ«å¤„ `reset()` æˆ– `unregister_session`ï¼Œå¯¹è±¡ä¹Ÿä¸ä¼šè¢«é”€æ¯ï¼›
  * ç›´åˆ°å›è°ƒæ‰§è¡Œç»“æŸï¼Œ`self` ç¦»å¼€ä½œç”¨åŸŸï¼Œå¼•ç”¨è®¡æ•° -1ï¼Œæ‰å…è®¸ææ„ã€‚

---

### 3. åº•å±‚æ•ˆæœæ€»ç»“

* **ç±»ç»§æ‰¿ `enable_shared_from_this`** â†’ è·å¾—ä¸€ä¸ª `weak_ptr` æˆå‘˜ã€‚
* **ç¬¬ä¸€æ¬¡ç”¨ `make_shared` åˆ›å»ºå¯¹è±¡æ—¶** â†’ è¿™ä¸ª `weak_ptr` è¢«èµ‹å€¼ã€‚
* **è°ƒç”¨ `shared_from_this()`** â†’ ä» `weak_ptr` æå‡å‡ºä¸€ä¸ªæ–°çš„ `shared_ptr`ï¼ˆè®¡æ•° +1ï¼‰ã€‚
* **lambda æ•è·è¿™ä¸ª shared\_ptr** â†’ ç¡®ä¿å¼‚æ­¥å›è°ƒæœŸé—´å¯¹è±¡ä¸ä¼šæå‰é”€æ¯ã€‚

---

ğŸ’¡ ä¸€å¥è¯æ€»ç»“ï¼š
`shared_from_this` çš„åº•å±‚å°±æ˜¯ **å¯¹è±¡é‡Œè—äº†ä¸€ä¸ª `weak_ptr`**ï¼Œå®ƒèƒ½éšæ—¶å˜æˆ `shared_ptr` æ¥å»¶é•¿è‡ªå·±ç”Ÿå‘½å‘¨æœŸã€‚

---

è¦ä¸è¦æˆ‘å¸®ä½ ç”»ä¸€ä¸ª **â€œå¼•ç”¨è®¡æ•°å˜åŒ–æµç¨‹å›¾â€**ï¼ˆä» `make_shared<Session>` â†’ `do_read` â†’ å›è°ƒ â†’ ææ„ï¼‰ï¼Ÿé‚£æ ·ä½ èƒ½ç›´è§‚åœ°çœ‹åˆ°ä»€ä¹ˆæ—¶å€™å¼•ç”¨è®¡æ•° +1/-1ã€‚


---

è®©æˆ‘è¯¦ç»†è§£é‡ŠMessageRouterçš„ä½œç”¨ã€ä½¿ç”¨æµç¨‹å’Œå…³é”®å‡½æ•°è°ƒç”¨é“¾ã€‚

  MessageRouterçš„æ ¸å¿ƒä½œç”¨

  1. æ¶ˆæ¯åˆ†å‘ä¸­å¿ƒ

  MessageRouterå°±åƒä¸€ä¸ª"é‚®å±€åˆ†æ‹£ä¸­å¿ƒ"ï¼š
  - æ¥æ”¶ï¼šä»Sessionæ¥æ”¶å„ç§ç±»å‹çš„æ¶ˆæ¯
  - è¯†åˆ«ï¼šæ ¹æ®æ¶ˆæ¯ç±»å‹ç¡®å®šå¤„ç†æ–¹å¼
  - åˆ†å‘ï¼šå°†æ¶ˆæ¯è½¬å‘ç»™å¯¹åº”çš„å¤„ç†å™¨
  - ç»Ÿä¸€é”™è¯¯å¤„ç†ï¼šå¤„ç†æ— æ³•è¯†åˆ«çš„æ¶ˆæ¯ç±»å‹

  2. è§£è€¦ä¸šåŠ¡é€»è¾‘å’Œç½‘ç»œå±‚

  // æ²¡æœ‰Routerä¹‹å‰ - Sessionç›´æ¥å¤„ç†ä¸šåŠ¡é€»è¾‘
  void Session::handle_packet(const Packet& packet) {
      if (packet.has_echo_request()) {
          // Echoå¤„ç†é€»è¾‘å†™åœ¨Sessioné‡Œ
      } else if (packet.has_login_request()) {
          // ç™»å½•å¤„ç†é€»è¾‘ä¹Ÿå†™åœ¨Sessioné‡Œ
      } else if (packet.has_chat_message()) {
          // èŠå¤©å¤„ç†é€»è¾‘è¿˜æ˜¯å†™åœ¨Sessioné‡Œ
      }
      // é—®é¢˜ï¼šSessionå˜å¾—è¶Šæ¥è¶Šè‡ƒè‚¿ï¼Œè¿åå•ä¸€èŒè´£åŸåˆ™
  }

  // æœ‰Routerä¹‹å - Sessionåªè´Ÿè´£ç½‘ç»œï¼ŒRouterè´Ÿè´£åˆ†å‘
  void Session::handle_packet(const Packet& packet) {
      message_router_->route_message(packet, shared_from_this());
      // Sessionä¿æŒç®€æ´ï¼Œåªè´Ÿè´£ç½‘ç»œå±‚é¢çš„äº‹æƒ…
  }

  MessageRouterçš„å®Œæ•´ä½¿ç”¨æµç¨‹

  é˜¶æ®µ1: åˆå§‹åŒ–å’Œæ³¨å†Œ

  // 1. Serverå¯åŠ¨æ—¶åˆ›å»ºRouter
  Server::initialize_message_router() {
      message_router_ = std::make_shared<MessageRouter>();

      // 2. æ³¨å†Œå„ç§å¤„ç†å™¨
      auto echo_handler = std::make_shared<EchoHandler>();
      message_router_->register_handler(
          MessageRouter::MessageType::ECHO_REQUEST,
          echo_handler
      );

      // æœªæ¥ä¼šæ³¨å†Œæ›´å¤šå¤„ç†å™¨
      // auto login_handler = std::make_shared<LoginHandler>();
      // message_router_->register_handler(
      //     MessageRouter::MessageType::LOGIN_REQUEST,
      //     login_handler
      // );
  }

  é˜¶æ®µ2: æ¶ˆæ¯æ¥æ”¶å’Œè·¯ç”±

  // æ¶ˆæ¯æµç¨‹ï¼šClient â†’ Session â†’ Router â†’ Handler

  // 1. Sessionæ¥æ”¶åˆ°æ•°æ®
  void Session::do_read() {
      socket_.async_read_some(..., [this, self](ec, length) {
          // 2. è§£ææˆPacket
          process_frame_buffer();
      });
  }

  // 3. å¤„ç†å®Œæ•´çš„Frame
  void Session::process_frame_buffer() {
      ProtocolHandler::Frame frame;
      size_t consumed;

      if (ProtocolHandler::parse_frame(read_buffer_, frame, consumed)) {
          Packet packet;
          if (ProtocolHandler::deserialize_frame(frame.data, packet)) {
              // 4. å§”æ‰˜ç»™Routerå¤„ç†
              handle_packet(packet);
          }
      }
  }

  // 5. Sessionå§”æ‰˜ç»™Router
  void Session::handle_packet(const Packet& packet) {
      message_router_->route_message(packet, shared_from_this());
  }

  é˜¶æ®µ3: Routerå†…éƒ¨çš„å…³é”®å¤„ç†æµç¨‹

  bool MessageRouter::route_message(const Packet& packet, std::shared_ptr<Session> session) {
      // æ­¥éª¤1: ç¡®å®šæ¶ˆæ¯ç±»å‹
      MessageType type = determine_message_type(packet);

      // æ­¥éª¤2: æŸ¥æ‰¾å¯¹åº”çš„å¤„ç†å™¨
      auto it = handlers_.find(type);
      if (it == handlers_.end()) {
          // æ­¥éª¤3a: æœªçŸ¥æ¶ˆæ¯ç±»å‹ï¼Œå‘é€é”™è¯¯å“åº”
          send_error_response(3001, "Unsupported message type",
                            packet.sequence(), session);
          return false;
      }

      // æ­¥éª¤3b: è°ƒç”¨å…·ä½“å¤„ç†å™¨
      try {
          return it->second->handle(packet, session);
      } catch (const std::exception& e) {
          // æ­¥éª¤4: å¼‚å¸¸å¤„ç†
          send_error_response(3002, "Internal handler error",
                            packet.sequence(), session);
          return false;
      }
  }

  å…³é”®å‡½æ•°è°ƒç”¨é“¾åˆ†æ

  1. determine_message_type() - æ¶ˆæ¯ç±»å‹è¯†åˆ«

  MessageRouter::MessageType MessageRouter::determine_message_type(const Packet& packet) const {
      // åŸºäºProtobufçš„oneofå­—æ®µåˆ¤æ–­æ¶ˆæ¯ç±»å‹
      if (packet.has_echo_request()) {
          return MessageType::ECHO_REQUEST;
      }
      // æœªæ¥æ‰©å±•ï¼š
      // if (packet.has_login_request()) {
      //     return MessageType::LOGIN_REQUEST;
      // }
      // if (packet.has_register_request()) {
      //     return MessageType::REGISTER_REQUEST;
      // }

      return MessageType::UNKNOWN;
  }

  å…³é”®ä½œç”¨ï¼šå°†Protobufçš„åŠ¨æ€ç±»å‹æ£€æŸ¥è½¬æ¢ä¸ºRouterå†…éƒ¨çš„é™æ€æšä¸¾ç±»å‹ï¼Œä¾¿äºåç»­å¤„ç†ã€‚

  2. Handlerçš„handle()æ–¹æ³• - å…·ä½“ä¸šåŠ¡å¤„ç†

  // EchoHandlerçš„å¤„ç†é€»è¾‘
  bool EchoHandler::handle(const Packet& packet, std::shared_ptr<Session> session) {
      // 1. éªŒè¯æ¶ˆæ¯ç±»å‹ï¼ˆåŒé‡æ£€æŸ¥ï¼‰
      if (!packet.has_echo_request()) {
          return false;
      }

      // 2. æå–ä¸šåŠ¡æ•°æ®
      const auto& echo_req = packet.echo_request();
      std::string content = echo_req.content();

      // 3. æ‰§è¡Œä¸šåŠ¡é€»è¾‘ï¼ˆè¿™é‡Œæ˜¯ç®€å•çš„å›æ˜¾ï¼‰
      spdlog::info("EchoHandler processing: '{}'", content);

      // 4. åˆ›å»ºå“åº”æ¶ˆæ¯
      auto response = ProtocolHandler::create_echo_response(
          content,
          packet.sequence()
      );

      // 5. é€šè¿‡Sessionå‘é€å“åº”
      session->send_packet(response);

      return true;
  }

  3. send_error_response() - ç»Ÿä¸€é”™è¯¯å¤„ç†

  void MessageRouter::send_error_response(uint32_t error_code,
                                        const std::string& message,
                                        uint32_t sequence,
                                        std::shared_ptr<Session> session) {
      try {
          // 1. åˆ›å»ºæ ‡å‡†é”™è¯¯å“åº”
          auto error_packet = ProtocolHandler::create_error_response(
              error_code, message, sequence
          );

          // 2. å‘é€ç»™å®¢æˆ·ç«¯
          session->send_packet(error_packet);

          // 3. è®°å½•æ—¥å¿—
          spdlog::debug("Sent error response: code={}, message='{}'",
                       error_code, message);
      } catch (const std::exception& e) {
          spdlog::error("Failed to send error response: {}", e.what());
      }
  }

  Routerçš„æ‰©å±•æ€§è®¾è®¡

  æ·»åŠ æ–°æ¶ˆæ¯ç±»å‹çš„æµç¨‹

  // 1. åœ¨æšä¸¾ä¸­æ·»åŠ æ–°ç±»å‹
  enum class MessageType {
      ECHO_REQUEST,
      LOGIN_REQUEST,     // æ–°å¢
      REGISTER_REQUEST,  // æ–°å¢
      CHAT_MESSAGE,      // æ–°å¢
      UNKNOWN
  };

  // 2. åœ¨determine_message_typeä¸­æ·»åŠ è¯†åˆ«é€»è¾‘
  MessageType determine_message_type(const Packet& packet) const {
      if (packet.has_echo_request()) return MessageType::ECHO_REQUEST;
      if (packet.has_login_request()) return MessageType::LOGIN_REQUEST;  // æ–°å¢
      if (packet.has_register_request()) return MessageType::REGISTER_REQUEST;  // æ–°å¢
      if (packet.has_chat_message()) return MessageType::CHAT_MESSAGE;  // æ–°å¢
      return MessageType::UNKNOWN;
  }

  // 3. åˆ›å»ºæ–°çš„Handler
  class LoginHandler : public MessageHandler {
  public:
      bool handle(const Packet& packet, std::shared_ptr<Session> session) override {
          // å®ç°ç™»å½•é€»è¾‘
          const auto& login_req = packet.login_request();
          // ... éªŒè¯ç”¨æˆ·åå¯†ç 
          // ... åˆ›å»ºç™»å½•å“åº”
          return true;
      }
  };

  // 4. åœ¨Serveråˆå§‹åŒ–æ—¶æ³¨å†Œæ–°Handler
  void Server::initialize_message_router() {
      // ... ç°æœ‰çš„echo_handleræ³¨å†Œ

      auto login_handler = std::make_shared<LoginHandler>();
      message_router_->register_handler(MessageType::LOGIN_REQUEST, login_handler);
  }

  Routerçš„æ•°æ®æµå›¾

  graph TD
      A[Clientå‘é€Packet] --> B[Session::do_read]
      B --> C[Session::process_frame_buffer]
      C --> D[Session::handle_packet]
      D --> E[MessageRouter::route_message]

      E --> F[determine_message_type]
      F --> G{æ¶ˆæ¯ç±»å‹?}

      G -->|ECHO_REQUEST| H[EchoHandler::handle]
      G -->|LOGIN_REQUEST| I[LoginHandler::handle]
      G -->|UNKNOWN| J[send_error_response]

      H --> K[åˆ›å»ºEchoResponse]
      I --> L[åˆ›å»ºLoginResponse]
      J --> M[åˆ›å»ºErrorResponse]

      K --> N[Session::send_packet]
      L --> N
      M --> N
      N --> O[å‘é€å›Client]

      style E fill:#e1f5fe
      style F fill:#fff3e0
      style G fill:#f3e5f5

  Routerè§£å†³çš„æ ¸å¿ƒé—®é¢˜

  1. å¯æ‰©å±•æ€§

  // æ²¡æœ‰Routerï¼šæ¯æ·»åŠ æ–°åŠŸèƒ½éƒ½è¦ä¿®æ”¹Session
  void Session::handle_packet(const Packet& packet) {
      if (packet.has_echo_request()) { /* echoé€»è¾‘ */ }
      else if (packet.has_login_request()) { /* æ–°å¢loginé€»è¾‘ */ }
      else if (packet.has_register_request()) { /* æ–°å¢registeré€»è¾‘ */ }
      // Sessionè¶Šæ¥è¶Šè‡ƒè‚¿...
  }

  // æœ‰Routerï¼šæ·»åŠ æ–°åŠŸèƒ½åªéœ€è¦åˆ›å»ºæ–°Handlerå¹¶æ³¨å†Œ
  auto new_handler = std::make_shared<NewFeatureHandler>();
  router->register_handler(MessageType::NEW_FEATURE, new_handler);
  // Sessionä»£ç æ— éœ€ä¿®æ”¹

  2. èŒè´£åˆ†ç¦»

  - Sessionï¼šåªè´Ÿè´£ç½‘ç»œI/Oå’Œåè®®è§£æ
  - MessageRouterï¼šåªè´Ÿè´£æ¶ˆæ¯åˆ†å‘å’Œè·¯ç”±
  - MessageHandlerï¼šåªè´Ÿè´£å…·ä½“çš„ä¸šåŠ¡é€»è¾‘

  3. ç»Ÿä¸€é”™è¯¯å¤„ç†

  - æ‰€æœ‰æœªçŸ¥æ¶ˆæ¯ç±»å‹éƒ½æœ‰ç»Ÿä¸€çš„é”™è¯¯å“åº”
  - æ‰€æœ‰Handlerå¼‚å¸¸éƒ½æœ‰ç»Ÿä¸€çš„å¤„ç†æœºåˆ¶
  - é”™è¯¯ç å’Œé”™è¯¯æ¶ˆæ¯æ ‡å‡†åŒ–

  4. æµ‹è¯•å‹å¥½æ€§

  // å¯ä»¥å•ç‹¬æµ‹è¯•æ¯ä¸ªHandler
  TEST(EchoHandlerTest, BasicEcho) {
      auto handler = std::make_shared<EchoHandler>();
      auto mock_session = std::make_shared<MockSession>();

      Packet packet;
      packet.mutable_echo_request()->set_content("test");

      EXPECT_TRUE(handler->handle(packet, mock_session));
      EXPECT_EQ(mock_session->get_last_sent_message(), "test");
  }

  æ€»ç»“

  MessageRouteræ˜¯ä¸€ä¸ªæ¶ˆæ¯åˆ†å‘ä¸­å¿ƒï¼Œå®ƒçš„æ ¸å¿ƒä»·å€¼åœ¨äºï¼š

  1. è§£è€¦ï¼šå°†ç½‘ç»œå±‚(Session)å’Œä¸šåŠ¡å±‚(Handler)åˆ†ç¦»
  2. æ‰©å±•ï¼šæ–°å¢åŠŸèƒ½ä¸éœ€è¦ä¿®æ”¹ç°æœ‰ä»£ç 
  3. ç»Ÿä¸€ï¼šé”™è¯¯å¤„ç†ã€æ—¥å¿—è®°å½•ã€æ¶ˆæ¯è·¯ç”±çš„ç»Ÿä¸€ç®¡ç†
  4. å¯æµ‹è¯•ï¼šæ¯ä¸ªç»„ä»¶å¯ä»¥ç‹¬ç«‹æµ‹è¯•

  å…³é”®å‡½æ•°è°ƒç”¨é“¾ï¼š
  Session::handle_packet â†’ MessageRouter::route_message â†’ determine_message_type â†’ Handler::handle â†’
  Session::send_packet

  è¿™ç§è®¾è®¡ä¸ºåç»­çš„ç”¨æˆ·ç³»ç»Ÿã€èŠå¤©åŠŸèƒ½ã€ç¾¤ç»„åŠŸèƒ½ç­‰å¤æ‚ä¸šåŠ¡é€»è¾‘å¥ å®šäº†åšå®çš„æ¶æ„åŸºç¡€ã€‚

--- 


è¿™æ˜¯ä¸€ä¸ªéå¸¸æ·±å…¥çš„é—®é¢˜ï¼è®©æˆ‘è¯¦ç»†è§£é‡ŠAsioçš„äº‹ä»¶å¾ªç¯æœºåˆ¶ä»¥åŠå›è°ƒå‡½æ•°æ˜¯å¦‚ä½•è¢«è°ƒç”¨çš„ã€‚

  io_contextçš„äº‹ä»¶ç›‘å¬å’Œå›è°ƒæœºåˆ¶

  1. io_context.run() - äº‹ä»¶å¾ªç¯çš„æ ¸å¿ƒ

  // Server::run_worker_threads() - å¯åŠ¨äº‹ä»¶å¾ªç¯
  void Server::run_worker_threads() {
      const auto &server_config = config_.get_server_config();

      // åˆ›å»ºå¤šä¸ªå·¥ä½œçº¿ç¨‹
      for (int i = 0; i < server_config.worker_threads; ++i) {
          worker_threads_.emplace_back([this]() {
              try {
                  io_context_.run();  // â†â† è¿™é‡Œï¼äº‹ä»¶å¾ªç¯çš„æ ¸å¿ƒ
              } catch (const std::exception& e) {
                  spdlog::error("Worker thread error: {}", e.what());
              }
          });
      }
  }

  io_context_.run() çš„å·¥ä½œåŸç†ï¼š
  - é˜»å¡å¼ç›‘å¬ï¼šç›‘å¬æ‰€æœ‰æ³¨å†Œçš„å¼‚æ­¥æ“ä½œ
  - äº‹ä»¶åˆ†å‘ï¼šå½“ç½‘ç»œäº‹ä»¶å‘ç”Ÿæ—¶ï¼Œè°ƒç”¨å¯¹åº”çš„å›è°ƒå‡½æ•°
  - å¤šçº¿ç¨‹æ”¯æŒï¼šå¤šä¸ªçº¿ç¨‹å¯ä»¥åŒæ—¶è°ƒç”¨run()ï¼ŒAsioä¼šè‡ªåŠ¨åˆ†å‘äº‹ä»¶

  2. å¼‚æ­¥æ“ä½œçš„æ³¨å†Œè¿‡ç¨‹

  A. ç›‘å¬æ–°è¿æ¥ - acceptor.async_accept()

  void Server::do_accept() {
      auto new_session = std::make_shared<Session>(...);

      // å…³é”®ï¼å‘io_contextæ³¨å†Œ"æ¥å—è¿æ¥"äº‹ä»¶
      acceptor_.async_accept(
          new_session->socket_,  // ç›®æ ‡socket
          [this, new_session](std::error_code ec) {  // å›è°ƒå‡½æ•°
              if (!ec) {
                  new_session->start();  // è¿æ¥æˆåŠŸæ—¶çš„å¤„ç†
              } else {
                  spdlog::error("Accept failed: {}", ec.message());
              }

              if (running_) {
                  do_accept();  // ç»§ç»­ç›‘å¬æ–°è¿æ¥
              }
          }
      );
  }

  å†…éƒ¨æœºåˆ¶ï¼š
  1. acceptor_.async_accept() å‘æ“ä½œç³»ç»Ÿæ³¨å†Œç›‘å¬äº‹ä»¶
  2. io_context è®°å½•è¿™ä¸ªå¼‚æ­¥æ“ä½œå’Œå¯¹åº”çš„å›è°ƒå‡½æ•°
  3. å½“æ–°å®¢æˆ·ç«¯è¿æ¥æ—¶ï¼Œæ“ä½œç³»ç»Ÿé€šçŸ¥io_context
  4. io_context.run() è°ƒç”¨æ³¨å†Œçš„lambdaå›è°ƒå‡½æ•°

  B. ç›‘å¬æ•°æ®è¯»å– - socket.async_read_some()

  void Session::do_read() {
      auto self(shared_from_this());  // ä¿æŒSessionå­˜æ´»

      // å…³é”®ï¼å‘io_contextæ³¨å†Œ"æ•°æ®å¯è¯»"äº‹ä»¶
      socket_.async_read_some(
          asio::buffer(data_, max_length),  // è¯»å–ç¼“å†²åŒº
          [this, self](std::error_code ec, std::size_t length) {  // å›è°ƒå‡½æ•°
              if (!ec) {
                  // æ•°æ®åˆ°è¾¾æ—¶çš„å¤„ç†
                  std::vector<uint8_t> received_data(data_, data_ + length);
                  read_buffer_.insert(read_buffer_.end(),
                                    received_data.begin(), received_data.end());

                  process_frame_buffer();  // å¤„ç†æ¥æ”¶åˆ°çš„æ•°æ®
                  do_read();  // ç»§ç»­ç›‘å¬æ›´å¤šæ•°æ®
              } else {
                  spdlog::info("Client disconnected: {}", ec.message());
                  // è¿æ¥æ–­å¼€ï¼Œä¸å†ç»§ç»­è¯»å–
              }
          }
      );
  }

  C. ç›‘å¬æ•°æ®å†™å…¥ - socket.async_write_some()

  void Session::do_write() {
      auto self(shared_from_this());

      // å‘io_contextæ³¨å†Œ"å¯å†™å…¥æ•°æ®"äº‹ä»¶
      asio::async_write(
          socket_,
          asio::buffer(write_buffer_),
          [this, self](std::error_code ec, std::size_t length) {
              if (!ec) {
                  write_buffer_.clear();  // å†™å…¥æˆåŠŸï¼Œæ¸…ç©ºç¼“å†²åŒº
              } else {
                  spdlog::error("Write failed: {}", ec.message());
              }
          }
      );
  }

  3. äº‹ä»¶å¾ªç¯çš„å®Œæ•´æµç¨‹

  graph TD
      A[æœåŠ¡å™¨å¯åŠ¨] --> B[Server::start]
      B --> C[acceptor_.bind/listen]
      C --> D[do_accept æ³¨å†Œacceptäº‹ä»¶]
      D --> E[å¯åŠ¨å·¥ä½œçº¿ç¨‹]
      E --> F[io_context.run å¼€å§‹äº‹ä»¶å¾ªç¯]

      F --> G{ç›‘å¬ç³»ç»Ÿäº‹ä»¶}
      G -->|æ–°è¿æ¥åˆ°è¾¾| H[è°ƒç”¨acceptå›è°ƒ]
      G -->|æ•°æ®å¯è¯»| I[è°ƒç”¨readå›è°ƒ]
      G -->|å¯å†™å…¥æ•°æ®| J[è°ƒç”¨writeå›è°ƒ]
      G -->|è¿æ¥æ–­å¼€| K[è°ƒç”¨errorå›è°ƒ]

      H --> L[åˆ›å»ºæ–°Session]
      L --> M[Session::start]
      M --> N[æ³¨å†Œreadäº‹ä»¶]
      N --> G

      I --> O[process_frame_buffer]
      O --> P[handle_packet]
      P --> Q[MessageRouter::route_message]
      Q --> R[Handler::handle]
      R --> S[send_packet]
      S --> T[æ³¨å†Œwriteäº‹ä»¶]
      T --> G

      style F fill:#e1f5fe
      style G fill:#fff3e0
      style Q fill:#f3e5f5

  4. ç³»ç»Ÿè°ƒç”¨å±‚é¢çš„æœºåˆ¶

  Linuxä¸Šçš„å®ç°ï¼ˆepollï¼‰

  // Asioå†…éƒ¨ï¼ˆç®€åŒ–ç‰ˆæœ¬ï¼‰
  class io_context {
      int epoll_fd_;  // epollæ–‡ä»¶æè¿°ç¬¦
      std::vector<epoll_event> events_;
      std::map<int, std::function<void()>> callbacks_;  // fdåˆ°å›è°ƒçš„æ˜ å°„

  public:
      void run() {
          while (true) {
              // 1. ç­‰å¾…ç³»ç»Ÿäº‹ä»¶
              int nfds = epoll_wait(epoll_fd_, events_.data(),
                                   events_.size(), -1);

              // 2. å¤„ç†æ¯ä¸ªäº‹ä»¶
              for (int i = 0; i < nfds; ++i) {
                  int fd = events_[i].data.fd;

                  // 3. æŸ¥æ‰¾å¹¶è°ƒç”¨å¯¹åº”çš„å›è°ƒå‡½æ•°
                  auto it = callbacks_.find(fd);
                  if (it != callbacks_.end()) {
                      it->second();  // â†â† è¿™é‡Œè°ƒç”¨æˆ‘ä»¬æ³¨å†Œçš„lambdaå‡½æ•°ï¼
                  }
              }
          }
      }

      void async_accept(socket& s, callback_func cb) {
          // 1. å‘epollæ³¨å†Œsocketçš„ç›‘å¬äº‹ä»¶
          epoll_event ev;
          ev.events = EPOLLIN;
          ev.data.fd = s.native_handle();
          epoll_ctl(epoll_fd_, EPOLL_CTL_ADD, s.native_handle(), &ev);

          // 2. ä¿å­˜å›è°ƒå‡½æ•°
          callbacks_[s.native_handle()] = cb;
      }
  };

  5. å›è°ƒå‡½æ•°è°ƒç”¨çš„è¯¦ç»†è·Ÿè¸ª

  åœºæ™¯ï¼šå®¢æˆ·ç«¯å‘é€æ•°æ®

  // 1. å®¢æˆ·ç«¯æ‰§è¡Œï¼šecho "hello" | nc localhost 8080

  // 2. Linuxå†…æ ¸æ£€æµ‹åˆ°socketæœ‰æ•°æ®å¯è¯»
  // 3. epoll_waitè¿”å›ï¼ŒæŒ‡ç¤ºæŸä¸ªfdæœ‰EPOLLINäº‹ä»¶

  // 4. io_context.run()ä¸­çš„äº‹ä»¶å¤„ç†å¾ªç¯ï¼š
  for (auto& event : ready_events) {
      if (event.data.fd == session->socket_.native_handle()) {
          // 5. æŸ¥æ‰¾å¯¹åº”çš„å›è°ƒå‡½æ•°ï¼ˆä¹‹å‰åœ¨do_readä¸­æ³¨å†Œçš„lambdaï¼‰
          auto callback = registered_callbacks[event.data.fd];

          // 6. è°ƒç”¨å›è°ƒå‡½æ•°
          callback();  // è¿™é‡Œè°ƒç”¨Session::do_readä¸­çš„lambda
      }
  }

  // 7. lambdaå‡½æ•°æ‰§è¡Œï¼š
  [this, self](std::error_code ec, std::size_t length) {
      // 8. å¤„ç†æ¥æ”¶åˆ°çš„æ•°æ®
      process_frame_buffer();

      // 9. è§£æå‡ºå®Œæ•´çš„Packetå
      handle_packet(packet);

      // 10. å§”æ‰˜ç»™MessageRouter
      message_router_->route_message(packet, shared_from_this());

      // 11. Routerè°ƒç”¨å¯¹åº”çš„Handler
      echo_handler->handle(packet, session);

      // 12. Handlerå‘é€å“åº”
      session->send_packet(response);

      // 13. ç»§ç»­ç›‘å¬æ›´å¤šæ•°æ®
      do_read();  // æ³¨å†Œæ–°çš„async_read_some
  }

  6. å¤šçº¿ç¨‹äº‹ä»¶åˆ†å‘

  // 4ä¸ªå·¥ä½œçº¿ç¨‹åŒæ—¶è¿è¡Œio_context.run()
  void Server::run_worker_threads() {
      for (int i = 0; i < 4; ++i) {
          worker_threads_.emplace_back([this]() {
              io_context_.run();  // çº¿ç¨‹1,2,3,4éƒ½åœ¨è¿™é‡Œç­‰å¾…äº‹ä»¶
          });
      }
  }

  Asioçš„çº¿ç¨‹å®‰å…¨ä¿è¯ï¼š
  - æ¯ä¸ªäº‹ä»¶åªä¼šè¢«ä¸€ä¸ªçº¿ç¨‹å¤„ç†
  - å¤šä¸ªçº¿ç¨‹å¯ä»¥å¹¶è¡Œå¤„ç†ä¸åŒçš„äº‹ä»¶
  - åŒä¸€ä¸ªSessionçš„äº‹ä»¶ä¼šè¢«ä¸²è¡Œå¤„ç†ï¼ˆé¿å…ç«æ€æ¡ä»¶ï¼‰

  7. å…³é”®çš„æ³¨å†Œæ—¶æœº

  // æ—¶æœº1ï¼šæœåŠ¡å™¨å¯åŠ¨æ—¶æ³¨å†Œacceptäº‹ä»¶
  bool Server::start() {
      acceptor_.listen();
      do_accept();  // â†â† æ³¨å†Œç¬¬ä¸€ä¸ªacceptäº‹ä»¶
      run_worker_threads();  // å¯åŠ¨äº‹ä»¶å¾ªç¯
  }

  // æ—¶æœº2ï¼šæ–°è¿æ¥å»ºç«‹æ—¶æ³¨å†Œreadäº‹ä»¶
  void Session::start() {
      do_read();  // â†â† æ³¨å†Œreadäº‹ä»¶
  }

  // æ—¶æœº3ï¼šå¤„ç†å®Œæ•°æ®åç»§ç»­æ³¨å†Œreadäº‹ä»¶
  void Session::do_read() {
      socket_.async_read_some(..., [this, self](...) {
          if (!ec) {
              process_frame_buffer();
              do_read();  // â†â† é€’å½’æ³¨å†Œä¸‹ä¸€ä¸ªreadäº‹ä»¶
          }
      });
  }

  // æ—¶æœº4ï¼šéœ€è¦å‘é€æ•°æ®æ—¶æ³¨å†Œwriteäº‹ä»¶
  void Session::send_packet(const Packet& packet) {
      write_buffer_ = ProtocolHandler::serialize_frame(packet);
      do_write();  // â†â† æ³¨å†Œwriteäº‹ä»¶
  }

  æ€»ç»“

  å›è°ƒå‡½æ•°è¢«è°ƒç”¨çš„å®Œæ•´é“¾è·¯ï¼š

  1. æ³¨å†Œé˜¶æ®µï¼šasync_xxx() å‘io_contextæ³¨å†Œäº‹ä»¶å’Œå›è°ƒ
  2. ç›‘å¬é˜¶æ®µï¼šio_context.run() é€šè¿‡ç³»ç»Ÿè°ƒç”¨ç›‘å¬æ‰€æœ‰æ³¨å†Œçš„äº‹ä»¶
  3. äº‹ä»¶å‘ç”Ÿï¼šç½‘ç»œäº‹ä»¶è§¦å‘ï¼ˆæ–°è¿æ¥ã€æ•°æ®åˆ°è¾¾ã€è¿æ¥æ–­å¼€ç­‰ï¼‰
  4. äº‹ä»¶åˆ†å‘ï¼šio_context æŸ¥æ‰¾å¯¹åº”çš„å›è°ƒå‡½æ•°å¹¶è°ƒç”¨
  5. ä¸šåŠ¡å¤„ç†ï¼šå›è°ƒå‡½æ•°æ‰§è¡Œä¸šåŠ¡é€»è¾‘ï¼ˆåŒ…æ‹¬è°ƒç”¨MessageRouterå’ŒHandlerï¼‰
  6. ç»§ç»­ç›‘å¬ï¼šå›è°ƒå‡½æ•°ä¸­æ³¨å†Œæ–°çš„å¼‚æ­¥æ“ä½œï¼Œå¾ªç¯ç»§ç»­

  å…³é”®ä»£ç ä½ç½®ï¼š
  - äº‹ä»¶å¾ªç¯ï¼šio_context_.run() åœ¨ Server::run_worker_threads()
  - Acceptæ³¨å†Œï¼šacceptor_.async_accept() åœ¨ Server::do_accept()
  - Readæ³¨å†Œï¼šsocket_.async_read_some() åœ¨ Session::do_read()
  - Writeæ³¨å†Œï¼šasio::async_write() åœ¨ Session::do_write()

  è¿™å°±æ˜¯ä¸ºä»€ä¹ˆæˆ‘ä»¬çš„MessageRouterå’ŒHandlerèƒ½å¤Ÿè¢«æ­£ç¡®è°ƒç”¨çš„åº•å±‚æœºåˆ¶ï¼

---

â— è¿™æ˜¯ä¸€ä¸ªéå¸¸å¥½çš„çº¿ç¨‹æ¨¡å‹é—®é¢˜ï¼è®©æˆ‘è¯¦ç»†åˆ†ææˆ‘ä»¬é¡¹ç›®ä¸­çš„çº¿ç¨‹æƒ…å†µå’ŒAsioçš„çº¿ç¨‹æ¨¡å‹ã€‚

  å½“å‰é¡¹ç›®çš„çº¿ç¨‹æ¨¡å‹åˆ†æ

  1. ä½¿ç”¨å¤šä¸ªWorkerçº¿ç¨‹æ—¶çš„æƒ…å†µ

  // Server::run_worker_threads() - å½“å‰å®ç°
  void Server::run_worker_threads() {
      const auto &server_config = config_.get_server_config();

      // åˆ›å»ºå¤šä¸ªå·¥ä½œçº¿ç¨‹ï¼ˆé»˜è®¤4ä¸ªï¼‰
      for (int i = 0; i < server_config.worker_threads; ++i) {
          worker_threads_.emplace_back([this]() {
              try {
                  io_context_.run();  // æ¯ä¸ªçº¿ç¨‹éƒ½è°ƒç”¨run()
              } catch (const std::exception& e) {
                  spdlog::error("Worker thread error: {}", e.what());
              }
          });
      }

      // ä¸»çº¿ç¨‹ç­‰å¾…æ‰€æœ‰å·¥ä½œçº¿ç¨‹
      for (auto &thread : worker_threads_) {
          thread.join();
      }
  }

  å½“å‰é…ç½®ä¸‹çš„çº¿ç¨‹æƒ…å†µï¼š
  - ä¸»çº¿ç¨‹ï¼ˆThread 0ï¼‰ï¼šæ‰§è¡ŒServer::start()ï¼Œç„¶ååœ¨join()å¤„ç­‰å¾…
  - Workerçº¿ç¨‹1-4ï¼šæ¯ä¸ªéƒ½åœ¨æ‰§è¡Œio_context_.run()
  - æ€»çº¿ç¨‹æ•°ï¼š5ä¸ªï¼ˆ1ä¸ªä¸»çº¿ç¨‹ + 4ä¸ªå·¥ä½œçº¿ç¨‹ï¼‰

  2. å¦‚æœä¸ä½¿ç”¨å¤šä¸ªWorkerçº¿ç¨‹çš„æƒ…å†µ

  // å‡è®¾ç®€åŒ–ç‰ˆæœ¬çš„run_worker_threads()
  void Server::run_single_thread() {
      try {
          io_context_.run();  // ä¸»çº¿ç¨‹ç›´æ¥è°ƒç”¨run()
      } catch (const std::exception& e) {
          spdlog::error("IO error: {}", e.what());
      }
  }

  ç®€åŒ–ç‰ˆæœ¬çš„çº¿ç¨‹æƒ…å†µï¼š
  - ä¸»çº¿ç¨‹ï¼ˆThread 0ï¼‰ï¼šæ‰§è¡Œæ‰€æœ‰æ“ä½œï¼ŒåŒ…æ‹¬io_context_.run()
  - æ€»çº¿ç¨‹æ•°ï¼š1ä¸ªï¼ˆåªæœ‰ä¸»çº¿ç¨‹ï¼‰

  çº¿ç¨‹ä¸å›è°ƒæ‰§è¡Œçš„å…³ç³»

  é‡è¦æ¦‚å¿µï¼šAsioçš„çº¿ç¨‹æ¨¡å‹

  // å…³é”®ç†è§£ï¼šå¤šä¸ªçº¿ç¨‹å…±äº«åŒä¸€ä¸ªio_context
  class Server {
      asio::io_context io_context_;  // åªæœ‰ä¸€ä¸ªio_contextå®ä¾‹

      void run_worker_threads() {
          // 4ä¸ªçº¿ç¨‹éƒ½è°ƒç”¨åŒä¸€ä¸ªio_contextçš„run()
          for (int i = 0; i < 4; ++i) {
              worker_threads_.emplace_back([this]() {
                  io_context_.run();  // å…±äº«åŒä¸€ä¸ªio_context
              });
          }
      }
  };

  äº‹ä»¶å¤„ç†çš„çº¿ç¨‹åˆ†é…

  graph TD
      A[io_context äº‹ä»¶é˜Ÿåˆ—] --> B{æœ‰äº‹ä»¶åˆ°è¾¾}
      B -->|æ–°è¿æ¥| C[ä»»æ„ä¸€ä¸ªWorkerçº¿ç¨‹å¤„ç†]
      B -->|Session1æ•°æ®| D[ä»»æ„ä¸€ä¸ªWorkerçº¿ç¨‹å¤„ç†]
      B -->|Session2æ•°æ®| E[ä»»æ„ä¸€ä¸ªWorkerçº¿ç¨‹å¤„ç†]
      B -->|Session3æ–­å¼€| F[ä»»æ„ä¸€ä¸ªWorkerçº¿ç¨‹å¤„ç†]

      C --> G[æ‰§è¡Œacceptå›è°ƒ<br/>åˆ›å»ºæ–°Session]
      D --> H[æ‰§è¡Œreadå›è°ƒ<br/>è°ƒç”¨MessageRouter]
      E --> I[æ‰§è¡Œreadå›è°ƒ<br/>è°ƒç”¨MessageRouter]
      F --> J[æ‰§è¡Œerrorå›è°ƒ<br/>æ¸…ç†Session]

      style A fill:#e1f5fe
      style G fill:#fff3e0
      style H fill:#fff3e0
      style I fill:#fff3e0
      style J fill:#ffebee

  å…·ä½“çš„æ‰§è¡Œæµç¨‹åˆ†æ

  åœºæ™¯1ï¼šæ–°è¿æ¥åˆ°è¾¾

  // do_accept()æ³¨å†Œçš„å›è°ƒå¯èƒ½åœ¨ä»»æ„Workerçº¿ç¨‹ä¸­æ‰§è¡Œ
  acceptor_.async_accept(new_session->socket_,
      [this, new_session](std::error_code ec) {
          // è¿™ä¸ªlambdaå¯èƒ½åœ¨Workerçº¿ç¨‹1,2,3,4ä¸­çš„ä»»æ„ä¸€ä¸ªæ‰§è¡Œ

          if (!ec) {
              spdlog::info("Thread {} handling new connection",
                          std::this_thread::get_id());
              new_session->start();  // åœ¨å½“å‰Workerçº¿ç¨‹ä¸­æ‰§è¡Œ
          }

          if (running_) {
              do_accept();  // åœ¨å½“å‰Workerçº¿ç¨‹ä¸­é‡æ–°æ³¨å†Œaccept
          }
      }
  );

  åœºæ™¯2ï¼šSessionæ•°æ®å¤„ç†

  // do_read()æ³¨å†Œçš„å›è°ƒä¹Ÿå¯èƒ½åœ¨ä»»æ„Workerçº¿ç¨‹ä¸­æ‰§è¡Œ
  socket_.async_read_some(asio::buffer(data_, max_length),
      [this, self](std::error_code ec, std::size_t length) {
          // è¿™ä¸ªlambdaå¯èƒ½åœ¨Workerçº¿ç¨‹1,2,3,4ä¸­çš„ä»»æ„ä¸€ä¸ªæ‰§è¡Œ

          if (!ec) {
              spdlog::debug("Thread {} processing data for session",
                           std::this_thread::get_id());

              // æ‰€æœ‰è¿™äº›éƒ½åœ¨å½“å‰Workerçº¿ç¨‹ä¸­æ‰§è¡Œï¼š
              process_frame_buffer();           // è§£æåè®®
              handle_packet(packet);            // å¤„ç†åŒ…
              message_router_->route_message(); // è·¯ç”±æ¶ˆæ¯
              handler->handle();                // ä¸šåŠ¡å¤„ç†
              send_packet(response);            // å‘é€å“åº”

              do_read();  // åœ¨å½“å‰Workerçº¿ç¨‹ä¸­é‡æ–°æ³¨å†Œread
          }
      }
  );

  çº¿ç¨‹å®‰å…¨çš„è€ƒè™‘

  1. Sessionçº§åˆ«çš„çº¿ç¨‹å®‰å…¨

  // æ¯ä¸ªSessionçš„äº‹ä»¶æ˜¯ä¸²è¡Œå¤„ç†çš„
  void Session::do_read() {
      auto self(shared_from_this());
      socket_.async_read_some(..., [this, self](...) {
          // Asioä¿è¯ï¼šåŒä¸€ä¸ªsocketçš„äº‹ä»¶ä¸ä¼šå¹¶å‘æ‰§è¡Œ
          // å³ä½¿æœ‰å¤šä¸ªWorkerçº¿ç¨‹ï¼ŒåŒä¸€ä¸ªSessionçš„å›è°ƒæ˜¯ä¸²è¡Œçš„

          process_frame_buffer();  // å®‰å…¨ï¼šä¸ä¼šå¹¶å‘æ‰§è¡Œ
          handle_packet(packet);   // å®‰å…¨ï¼šä¸ä¼šå¹¶å‘æ‰§è¡Œ
          do_read();              // å®‰å…¨ï¼šä¸²è¡Œæ³¨å†Œä¸‹ä¸€ä¸ªè¯»å–
      });
  }

  2. SessionManagerçš„çº¿ç¨‹å®‰å…¨

  class SessionManager {
      mutable std::mutex sessions_mutex_;  // å¿…é¡»çš„ï¼å¤šçº¿ç¨‹è®¿é—®

      bool register_session(std::shared_ptr<Session> session) {
          std::lock_guard<std::mutex> lock(sessions_mutex_);
          // å¯èƒ½æœ‰å¤šä¸ªWorkerçº¿ç¨‹åŒæ—¶è°ƒç”¨è¿™ä¸ªå‡½æ•°
          // å› ä¸ºacceptå›è°ƒå¯èƒ½åœ¨ä¸åŒçº¿ç¨‹ä¸­æ‰§è¡Œ
          active_sessions_.insert(session);
      }
  };

  3. MessageRouterçš„çº¿ç¨‹å®‰å…¨

  class MessageRouter {
      // MessageRouteræœ¬èº«æ˜¯æ— çŠ¶æ€çš„ï¼Œåªè¯»æ“ä½œ
      std::unordered_map<MessageType, std::shared_ptr<MessageHandler>> handlers_;

      bool route_message(const Packet& packet, std::shared_ptr<Session> session) {
          // è¿™ä¸ªå‡½æ•°å¯èƒ½è¢«å¤šä¸ªWorkerçº¿ç¨‹å¹¶å‘è°ƒç”¨
          // ä½†åªæ˜¯è¯»å–handlers_æ˜ å°„ï¼Œæ˜¯çº¿ç¨‹å®‰å…¨çš„
          auto it = handlers_.find(type);  // åªè¯»æ“ä½œï¼Œå®‰å…¨
          return it->second->handle(packet, session);
      }
  };

  å®é™…çš„çº¿ç¨‹æ‰§è¡Œç¤ºä¾‹

  å‡è®¾æœ‰3ä¸ªå®¢æˆ·ç«¯åŒæ—¶è¿æ¥

  // æ—¶é—´çº¿ç¤ºä¾‹ï¼š
  // T0: æœåŠ¡å™¨å¯åŠ¨ï¼Œ4ä¸ªWorkerçº¿ç¨‹å¼€å§‹è¿è¡Œio_context_.run()

  // T1: Client1è¿æ¥åˆ°è¾¾
  //     Workerçº¿ç¨‹2 æ‰§è¡Œacceptå›è°ƒ â†’ åˆ›å»ºSession1 â†’ æ³¨å†ŒSession1çš„readäº‹ä»¶

  // T2: Client2è¿æ¥åˆ°è¾¾
  //     Workerçº¿ç¨‹1 æ‰§è¡Œacceptå›è°ƒ â†’ åˆ›å»ºSession2 â†’ æ³¨å†ŒSession2çš„readäº‹ä»¶

  // T3: Client1å‘é€æ•°æ®
  //     Workerçº¿ç¨‹3 æ‰§è¡ŒSession1çš„readå›è°ƒ â†’ è°ƒç”¨MessageRouter â†’ å¤„ç†ä¸šåŠ¡é€»è¾‘

  // T4: Client2å‘é€æ•°æ®
  //     Workerçº¿ç¨‹4 æ‰§è¡ŒSession2çš„readå›è°ƒ â†’ è°ƒç”¨MessageRouter â†’ å¤„ç†ä¸šåŠ¡é€»è¾‘

  // T5: Client3è¿æ¥åˆ°è¾¾
  //     Workerçº¿ç¨‹2 æ‰§è¡Œacceptå›è°ƒ â†’ åˆ›å»ºSession3 â†’ æ³¨å†ŒSession3çš„readäº‹ä»¶

  å…³é”®è§‚å¯Ÿï¼š
  - åˆ›å»ºSessionçš„çº¿ç¨‹ å’Œ å¤„ç†Sessionæ•°æ®çš„çº¿ç¨‹ å¯èƒ½ä¸åŒ
  - åŒä¸€ä¸ªSession çš„æ‰€æœ‰äº‹ä»¶éƒ½æ˜¯ä¸²è¡Œå¤„ç†çš„
  - ä¸åŒSession çš„äº‹ä»¶å¯ä»¥å¹¶è¡Œå¤„ç†

  ä¸åŒé…ç½®ä¸‹çš„çº¿ç¨‹æ•°é‡

  é…ç½®1ï¼šå•çº¿ç¨‹æ¨¡å¼

  // config.json
  {
    "server": {
      "worker_threads": 1
    }
  }
  çº¿ç¨‹æ•°é‡ï¼š2ä¸ªï¼ˆä¸»çº¿ç¨‹ + 1ä¸ªWorkerçº¿ç¨‹ï¼‰

  é…ç½®2ï¼šæ— Workerçº¿ç¨‹ï¼ˆç†è®ºä¸Šçš„ç®€åŒ–ç‰ˆï¼‰

  // å¦‚æœç›´æ¥åœ¨ä¸»çº¿ç¨‹è¿è¡Œ
  bool Server::start() {
      // ... åˆå§‹åŒ–
      do_accept();
      io_context_.run();  // ä¸»çº¿ç¨‹ç›´æ¥è¿è¡Œäº‹ä»¶å¾ªç¯
      return true;
  }
  çº¿ç¨‹æ•°é‡ï¼š1ä¸ªï¼ˆåªæœ‰ä¸»çº¿ç¨‹ï¼‰

  é…ç½®3ï¼šå½“å‰é»˜è®¤é…ç½®

  // config.json
  {
    "server": {
      "worker_threads": 4
    }
  }
  çº¿ç¨‹æ•°é‡ï¼š5ä¸ªï¼ˆä¸»çº¿ç¨‹ + 4ä¸ªWorkerçº¿ç¨‹ï¼‰

  æ€§èƒ½å½±å“åˆ†æ

  å•çº¿ç¨‹ vs å¤šçº¿ç¨‹

  // å•çº¿ç¨‹æ¨¡å¼çš„é™åˆ¶
  void single_thread_scenario() {
      // æ‰€æœ‰æ“ä½œéƒ½åœ¨ä¸€ä¸ªçº¿ç¨‹ä¸­ä¸²è¡Œæ‰§è¡Œï¼š
      // 1. å¤„ç†æ–°è¿æ¥
      // 2. å¤„ç†Session1çš„æ•°æ®
      // 3. å¤„ç†Session2çš„æ•°æ®
      // 4. å¤„ç†Session3çš„æ•°æ®
      // å¦‚æœæŸä¸ªHandlerå¤„ç†æ—¶é—´é•¿ï¼Œä¼šé˜»å¡å…¶ä»–æ‰€æœ‰æ“ä½œ
  }

  // å¤šçº¿ç¨‹æ¨¡å¼çš„ä¼˜åŠ¿
  void multi_thread_scenario() {
      // æ“ä½œå¯ä»¥å¹¶è¡Œæ‰§è¡Œï¼š
      // Workerçº¿ç¨‹1: å¤„ç†æ–°è¿æ¥
      // Workerçº¿ç¨‹2: å¤„ç†Session1çš„æ•°æ®ï¼ˆCPUå¯†é›†å‹æ“ä½œï¼‰
      // Workerçº¿ç¨‹3: å¤„ç†Session2çš„æ•°æ®ï¼ˆå¿«é€Ÿå“åº”ï¼‰
      // Workerçº¿ç¨‹4: å¤„ç†Session3çš„æ•°æ®ï¼ˆæ•°æ®åº“æŸ¥è¯¢ï¼‰
  }

  æ€»ç»“

  å›ç­”ä½ çš„æ ¸å¿ƒé—®é¢˜ï¼š

  1. æ˜¯å¦åŒä¸€çº¿ç¨‹ï¼Ÿ
    - ä¸ä¸€å®šï¼æ¥å—æ–°è¿æ¥ã€åˆ›å»ºSessionã€æ³¨å†Œå›è°ƒçš„æ“ä½œå¯èƒ½åœ¨ä¸åŒçš„Workerçº¿ç¨‹ä¸­æ‰§è¡Œ
    - ä½†åŒä¸€ä¸ªSessionçš„æ‰€æœ‰æ“ä½œæ˜¯ä¸²è¡Œçš„
  2. ä¸ä½¿ç”¨å¤šWorkerçº¿ç¨‹çš„çº¿ç¨‹æ•°ï¼š
    - æœ€å°‘1ä¸ªçº¿ç¨‹ï¼šä¸»çº¿ç¨‹ç›´æ¥è¿è¡Œio_context_.run()
    - é€šå¸¸2ä¸ªçº¿ç¨‹ï¼šä¸»çº¿ç¨‹ç­‰å¾… + 1ä¸ªWorkerçº¿ç¨‹è¿è¡Œäº‹ä»¶å¾ªç¯
  3. å½“å‰é…ç½®çš„çº¿ç¨‹æ•°ï¼š
    - 5ä¸ªçº¿ç¨‹ï¼šä¸»çº¿ç¨‹ + 4ä¸ªWorkerçº¿ç¨‹

  å…³é”®ç†è§£ï¼šAsioçš„ç¾å¦™ä¹‹å¤„åœ¨äºå®ƒè‡ªåŠ¨ç®¡ç†çº¿ç¨‹è°ƒåº¦ï¼Œæˆ‘ä»¬åªéœ€è¦æ³¨å†Œå¼‚æ­¥æ“ä½œå’Œå›è°ƒï¼ŒAsioä¼šè‡ªåŠ¨åœ¨å¯ç”¨çš„Workerçº¿ç¨‹ä¸­æ‰§è¡Œè¿™äº›
  å›è°ƒï¼Œæ— éœ€æˆ‘ä»¬æ‰‹åŠ¨ç®¡ç†çº¿ç¨‹é—´çš„åè°ƒã€‚

---

â— ç°åœ¨æˆ‘å‘ç°äº†ä¸€ä¸ªé‡è¦çš„é—®é¢˜ï¼è®©æˆ‘ä»”ç»†åˆ†ææºç ä¸­çš„é€’å½’è°ƒç”¨å’Œé”™è¯¯å¤„ç†ï¼š

  å…³é”®å‘ç°ï¼šæºç ä¸­çš„é—®é¢˜

  1. do_readä¸­ç¼ºå°‘é€’å½’è°ƒç”¨ï¼

  çœ‹ç¬¬85-107è¡Œçš„do_read()å‡½æ•°ï¼š

  void Session::do_read() {
      auto self(shared_from_this());
      socket_.async_read_some(
          asio::buffer(data_, data_.size()),
          [this, self](std::error_code ec, std::size_t length) {
              if (!ec) {
                  // å¤„ç†æ•°æ®...
                  process_frame_buffer();
              } else {
                  spdlog::info("Client disconnected: {}", ec.message());
                  // âš ï¸ é—®é¢˜ï¼šerroræ—¶æ²¡æœ‰ä»»ä½•å¤„ç†ï¼ŒSessionå°±ç»“æŸäº†ï¼
              }
              // âš ï¸ æ›´å¤§çš„é—®é¢˜ï¼šæˆåŠŸæ—¶ä¹Ÿæ²¡æœ‰è°ƒç”¨do_read()ç»§ç»­è¯»å–ï¼
          });
  }

  2. process_frame_bufferä¸­çš„é€’å½’è°ƒç”¨

  ä½†æ˜¯åœ¨ç¬¬175-177è¡Œçš„process_frame_buffer()ä¸­æœ‰ï¼š

  void Session::process_frame_buffer() {
      // ... å¤„ç†å®Œæ•´å¸§çš„é€»è¾‘

      // Continue reading
      do_read();  // â†â† è¿™é‡Œæœ‰é€’å½’è°ƒç”¨ï¼
  }

  å¼‚æ­¥"é€’å½’"ä¸ä¼šçˆ†æ ˆçš„åŸç†

  å…³é”®ç†è§£ï¼šè¿™ä¸æ˜¯çœŸæ­£çš„é€’å½’ï¼

  // çœ‹èµ·æ¥åƒé€’å½’ï¼Œå®é™…ä¸Šä¸æ˜¯ï¼
  void Session::do_read() {
      auto self(shared_from_this());
      socket_.async_read_some(...,
          [this, self](std::error_code ec, std::size_t length) {
              if (!ec) {
                  process_frame_buffer();  // åœ¨å›è°ƒä¸­è°ƒç”¨
              }
          }
      );
      // âš ï¸ æ³¨æ„ï¼šdo_read()å‡½æ•°åœ¨è¿™é‡Œå°±ç»“æŸäº†ï¼
      // æ ˆå¸§å·²ç»è¿”å›ï¼Œæ²¡æœ‰é€’å½’ï¼
  }

  void Session::process_frame_buffer() {
      // ... å¤„ç†é€»è¾‘
      do_read();  // è¿™æ˜¯ä¸€ä¸ªæ–°çš„å‡½æ•°è°ƒç”¨ï¼Œä¸æ˜¯é€’å½’ï¼
  }

  è°ƒç”¨æ ˆåˆ†æ

  graph TD
      A[Workerçº¿ç¨‹è°ƒç”¨do_read] --> B[æ³¨å†Œasync_read_some]
      B --> C[do_readå‡½æ•°è¿”å›ï¼Œæ ˆå¸§é”€æ¯]
      C --> D[çº¿ç¨‹ç»§ç»­å¤„ç†å…¶ä»–äº‹ä»¶]

      E[æ•°æ®åˆ°è¾¾ï¼Œè§¦å‘å›è°ƒ] --> F[io_contextè°ƒç”¨lambda]
      F --> G[lambdaè°ƒç”¨process_frame_buffer]
      G --> H[process_frame_bufferè°ƒç”¨do_read]
      H --> I[æ–°çš„async_read_someæ³¨å†Œ]
      I --> J[process_frame_bufferè¿”å›]
      J --> K[lambdaè¿”å›]
      K --> L[å›è°ƒå®Œæˆï¼Œç­‰å¾…ä¸‹æ¬¡æ•°æ®]

      style C fill:#e1f5fe
      style J fill:#e1f5fe
      style K fill:#e1f5fe

  å¯¹æ¯”ï¼šçœŸæ­£ä¼šçˆ†æ ˆçš„åŒæ­¥é€’å½’

  // å±é™©çš„åŒæ­¥é€’å½’ï¼ˆä¼šçˆ†æ ˆï¼‰
  void dangerous_sync_read() {
      char buffer[1024];

      // åŒæ­¥è¯»å–
      size_t bytes = socket_.read_some(asio::buffer(buffer));

      if (bytes > 0) {
          process_data(buffer, bytes);
          dangerous_sync_read();  // âš ï¸ çœŸæ­£çš„é€’å½’ï¼Œä¼šçˆ†æ ˆï¼
      }
  }

  // è°ƒç”¨æ ˆä¼šå˜æˆï¼š
  // dangerous_sync_read() ç¬¬1å±‚
  //   -> dangerous_sync_read() ç¬¬2å±‚
  //     -> dangerous_sync_read() ç¬¬3å±‚
  //       -> ... ç¬¬Nå±‚ (æœ€ç»ˆæ ˆæº¢å‡º)

  å¼‚æ­¥ç‰ˆæœ¬çš„å®‰å…¨æ€§

  // å®‰å…¨çš„å¼‚æ­¥"é€’å½’"ï¼ˆä¸ä¼šçˆ†æ ˆï¼‰
  void Session::do_read() {
      auto self(shared_from_this());
      socket_.async_read_some(..., [this, self](...) {
          if (!ec) {
              process_frame_buffer();
          }
      });
      // å‡½æ•°ç«‹å³è¿”å›ï¼Œæ ˆå¸§é”€æ¯
  }

  // è°ƒç”¨æ ˆå§‹ç»ˆä¿æŒæµ…å±‚ï¼š
  // Workerçº¿ç¨‹: io_context.run()
  //   -> å›è°ƒ: lambdaå‡½æ•°
  //     -> process_frame_buffer()
  //       -> do_read() (æ–°è°ƒç”¨ï¼Œä¸æ˜¯é€’å½’)
  //         -> æ³¨å†Œæ–°çš„å¼‚æ­¥æ“ä½œ
  //       <- do_read()è¿”å›
  //     <- process_frame_buffer()è¿”å›
  //   <- lambdaè¿”å›
  // <- ç­‰å¾…ä¸‹ä¸€ä¸ªäº‹ä»¶

  é”™è¯¯å¤„ç†çš„è¯¦ç»†åˆ†æ

  error_codeéé›¶æ—¶çš„å¤„ç†

  ç°åœ¨åˆ†ææºç ä¸­å½“error_codeéé›¶æ—¶ä¼šå‘ç”Ÿä»€ä¹ˆï¼š

  [this, self](std::error_code ec, std::size_t length) {
      if (!ec) {
          // æ­£å¸¸å¤„ç†...
      } else {
          spdlog::info("Client disconnected: {}", ec.message());
          // âš ï¸ å…³é”®é—®é¢˜ï¼šè¿™é‡Œä»€ä¹ˆéƒ½ä¸åšå°±è¿”å›äº†ï¼
      }
  }
  // lambdaç»“æŸï¼Œselfå¯¹è±¡ææ„ï¼Œå¼•ç”¨è®¡æ•°-1

  Sessionç”Ÿå‘½å‘¨æœŸçš„ç»“æŸ

  // é”™è¯¯å‘ç”Ÿæ—¶çš„å¼•ç”¨è®¡æ•°å˜åŒ–ï¼š
  void Session::do_read() {
      auto self(shared_from_this());  // å¼•ç”¨è®¡æ•°+1
      socket_.async_read_some(...,
          [this, self](std::error_code ec, std::size_t length) {
              if (ec) {
                  spdlog::info("Client disconnected: {}", ec.message());
                  return;  // ç›´æ¥è¿”å›ï¼Œä¸å†è°ƒç”¨do_read()
              }
              // æ­£å¸¸æµç¨‹...
          }
      );
  }
  // å½“é”™è¯¯å‘ç”Ÿæ—¶ï¼š
  // 1. lambdaè¿”å›ï¼Œselfææ„ï¼Œå¼•ç”¨è®¡æ•°-1
  // 2. æ²¡æœ‰æ–°çš„å¼‚æ­¥æ“ä½œæ³¨å†Œï¼ŒSessionä¸å†æ´»è·ƒ
  // 3. å¦‚æœSessionManagerä¸­æ²¡æœ‰å…¶ä»–å¼•ç”¨ï¼ŒSessionå¯¹è±¡ææ„

  å¸¸è§çš„error_codeç±»å‹

  // åˆ†æä¸åŒé”™è¯¯ç çš„å«ä¹‰ï¼š
  if (ec == asio::error::eof) {
      // å®¢æˆ·ç«¯æ­£å¸¸å…³é—­è¿æ¥ï¼ˆæ¯”å¦‚Ctrl+Cï¼‰
      spdlog::info("Client gracefully disconnected");
  } else if (ec == asio::error::connection_reset) {
      // å®¢æˆ·ç«¯å¼ºåˆ¶å…³é—­è¿æ¥
      spdlog::info("Connection reset by peer");
  } else if (ec == asio::error::connection_aborted) {
      // è¿æ¥è¢«ç»ˆæ­¢ï¼ˆç½‘ç»œé—®é¢˜ï¼‰
      spdlog::info("Connection aborted");
  } else if (ec == asio::error::timed_out) {
      // ç½‘ç»œè¶…æ—¶
      spdlog::info("Connection timed out");
  } else {
      // å…¶ä»–æœªçŸ¥é”™è¯¯
      spdlog::error("Unknown error: {}", ec.message());
  }

  // åœ¨æ‰€æœ‰é”™è¯¯æƒ…å†µä¸‹ï¼ŒSessionéƒ½ä¼šåœæ­¢è¯»å–
  // è¿™æ˜¯æ­£ç¡®çš„è¡Œä¸ºï¼Œå› ä¸ºè¿æ¥å·²ç»ä¸å¯ç”¨

  æºç ä¸­çš„è®¾è®¡é—®é¢˜

  é—®é¢˜1ï¼šdo_readä¸­ç¼ºå°‘ç»§ç»­è¯»å–

  å½“å‰çš„do_read()åœ¨æˆåŠŸå¤„ç†æ•°æ®åï¼Œæ²¡æœ‰ç»§ç»­è°ƒç”¨do_read()ï¼š

  // å½“å‰ä»£ç ï¼ˆæœ‰é—®é¢˜ï¼‰ï¼š
  void Session::do_read() {
      socket_.async_read_some(..., [this, self](...) {
          if (!ec) {
              process_frame_buffer();
              // âš ï¸ ç¼ºå°‘ï¼šdo_read();
          }
      });
  }

  ä¿®å¤æ–¹æ¡ˆï¼š
  // åº”è¯¥è¿™æ ·ï¼š
  void Session::do_read() {
      socket_.async_read_some(..., [this, self](...) {
          if (!ec) {
              process_frame_buffer();
              do_read();  // ç»§ç»­è¯»å–ä¸‹ä¸€æ‰¹æ•°æ®
          } else {
              spdlog::info("Client disconnected: {}", ec.message());
              // é”™è¯¯æ—¶ä¸å†è¯»å–ï¼ŒSessionè‡ªç„¶ç»“æŸ
          }
      });
  }

  é—®é¢˜2ï¼šprocess_frame_bufferä¸­çš„é‡å¤è°ƒç”¨

  void Session::process_frame_buffer() {
      // ... å¤„ç†å®Œæ•´å¸§

      // Continue reading
      do_read();  // è¿™é‡Œè°ƒç”¨do_read()
  }

  å¦‚æœdo_read()å·²ç»åœ¨æˆåŠŸå›è°ƒä¸­è°ƒç”¨äº†do_read()ï¼Œé‚£ä¹ˆprocess_frame_buffer()æœ«å°¾çš„è°ƒç”¨å°±æ˜¯å¤šä½™çš„ã€‚

  æ­£ç¡®çš„å¼‚æ­¥æ¨¡å¼

  æ ‡å‡†çš„å¼‚æ­¥è¯»å–æ¨¡å¼

  void Session::do_read() {
      auto self(shared_from_this());
      socket_.async_read_some(
          asio::buffer(data_, data_.size()),
          [this, self](std::error_code ec, std::size_t length) {
              if (!ec) {
                  // å¤„ç†æ¥æ”¶åˆ°çš„æ•°æ®
                  read_buffer_.insert(read_buffer_.end(),
                                    data_.begin(), data_.begin() + length);

                  // å¤„ç†å®Œæ•´çš„å¸§
                  process_frame_buffer();

                  // ç»§ç»­è¯»å–ï¼ˆå…³é”®ï¼ï¼‰
                  do_read();
              } else {
                  // è¿æ¥æ–­å¼€ï¼Œè®°å½•æ—¥å¿—ï¼ŒSessionç»“æŸ
                  spdlog::info("Client disconnected: {}", ec.message());
                  // ä¸è°ƒç”¨do_read()ï¼Œå¼‚æ­¥é“¾ç»“æŸ
              }
          }
      );
  }

  void Session::process_frame_buffer() {
      while (true) {
          // å¤„ç†å®Œæ•´å¸§...
          if (!complete_frame_found) {
              break;  // æ²¡æœ‰å®Œæ•´å¸§ï¼Œç­‰å¾…æ›´å¤šæ•°æ®
          }

          // å¤„ç†è¿™ä¸ªå®Œæ•´å¸§...
          handle_packet(packet);
      }
      // ä¸åœ¨è¿™é‡Œè°ƒç”¨do_read()ï¼Œå› ä¸ºè°ƒç”¨è€…ä¼šå¤„ç†
  }

  æ€»ç»“

  å›ç­”ä½ çš„æ ¸å¿ƒé—®é¢˜ï¼š

  1. ä¸ä¼šçˆ†æ ˆï¼š
    - å¼‚æ­¥"é€’å½’"ä¸æ˜¯çœŸæ­£çš„é€’å½’
    - æ¯æ¬¡do_read()è°ƒç”¨åç«‹å³è¿”å›ï¼Œæ ˆå¸§é”€æ¯
    - åç»­çš„è°ƒç”¨æ˜¯æ–°çš„äº‹ä»¶å›è°ƒï¼Œä¸åœ¨åŒä¸€ä¸ªè°ƒç”¨æ ˆä¸­
  2. error_codeéé›¶æ—¶ï¼š
    - è®°å½•æ–­å¼€æ—¥å¿—
    - ä¸å†è°ƒç”¨do_read()ï¼Œå¼‚æ­¥æ“ä½œé“¾ç»“æŸ
    - Sessionå¯¹è±¡çš„å¼•ç”¨è®¡æ•°å‡å°‘ï¼Œæœ€ç»ˆææ„
    - è¿™æ˜¯æ­£ç¡®çš„è¡Œä¸ºï¼Œå› ä¸ºè¿æ¥å·²ä¸å¯ç”¨
  3. æºç ä¸­çš„é—®é¢˜ï¼š
    - do_read()å›è°ƒä¸­ç¼ºå°‘ç»§ç»­è¯»å–çš„è°ƒç”¨
    - process_frame_buffer()ä¸­çš„do_read()è°ƒç”¨å¯èƒ½æ˜¯ä¸ºäº†è¡¥å¿è¿™ä¸ªç¼ºå¤±

  å¼‚æ­¥ç¼–ç¨‹çš„ç¾å¦™ä¹‹å¤„ï¼šé€šè¿‡äº‹ä»¶é©±åŠ¨çš„å›è°ƒæœºåˆ¶ï¼Œé¿å…äº†ä¼ ç»Ÿé€’å½’çš„æ ˆæº¢å‡ºé—®é¢˜ï¼ŒåŒæ—¶ä¿æŒäº†é€»è¾‘ä¸Šçš„è¿ç»­æ€§ã€‚